/**
 * Binance Simple Earn REST API
 *
 * OpenAPI Specification for the Binance Simple Earn REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { HistoryApi } from '../../../src/rest-api';
import {
    GetCollateralRecordRequest,
    GetFlexibleRedemptionRecordRequest,
    GetFlexibleRewardsHistoryRequest,
    GetFlexibleSubscriptionRecordRequest,
    GetLockedRedemptionRecordRequest,
    GetLockedRewardsHistoryRequest,
    GetLockedSubscriptionRecordRequest,
    GetRateHistoryRequest,
} from '../../../src/rest-api';
import type {
    GetCollateralRecordResponse,
    GetFlexibleRedemptionRecordResponse,
    GetFlexibleRewardsHistoryResponse,
    GetFlexibleSubscriptionRecordResponse,
    GetLockedRedemptionRecordResponse,
    GetLockedRewardsHistoryResponse,
    GetLockedSubscriptionRecordResponse,
    GetRateHistoryResponse,
} from '../../../src/rest-api/types';

describe('HistoryApi', () => {
    let client: HistoryApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new HistoryApi(config);
    });

    describe('getCollateralRecord()', () => {
        it('should execute getCollateralRecord() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        amount: '100.00000000',
                        productId: 'BUSD001',
                        asset: 'USDT',
                        createTime: 1575018510000,
                        type: 'REPAY',
                        productName: 'USDT',
                        orderId: 26055,
                    },
                ],
                total: '1',
            };

            const spy = jest.spyOn(client, 'getCollateralRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCollateralRecordResponse>)
            );
            const response = await client.getCollateralRecord();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getCollateralRecord() successfully with optional parameters', async () => {
            const params: GetCollateralRecordRequest = {
                productId: '1',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        amount: '100.00000000',
                        productId: 'BUSD001',
                        asset: 'USDT',
                        createTime: 1575018510000,
                        type: 'REPAY',
                        productName: 'USDT',
                        orderId: 26055,
                    },
                ],
                total: '1',
            };

            const spy = jest.spyOn(client, 'getCollateralRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCollateralRecordResponse>)
            );
            const response = await client.getCollateralRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getCollateralRecord').mockRejectedValueOnce(mockError);
            await expect(client.getCollateralRecord()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getFlexibleRedemptionRecord()', () => {
        it('should execute getFlexibleRedemptionRecord() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        amount: '10.54000000',
                        asset: 'USDT',
                        time: 1577257222000,
                        projectId: 'USDT001',
                        redeemId: 40607,
                        destAccount: 'SPOT',
                        status: 'PAID',
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getFlexibleRedemptionRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleRedemptionRecordResponse>)
            );
            const response = await client.getFlexibleRedemptionRecord();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFlexibleRedemptionRecord() successfully with optional parameters', async () => {
            const params: GetFlexibleRedemptionRecordRequest = {
                productId: '1',
                redeemId: '1',
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        amount: '10.54000000',
                        asset: 'USDT',
                        time: 1577257222000,
                        projectId: 'USDT001',
                        redeemId: 40607,
                        destAccount: 'SPOT',
                        status: 'PAID',
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getFlexibleRedemptionRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleRedemptionRecordResponse>)
            );
            const response = await client.getFlexibleRedemptionRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFlexibleRedemptionRecord')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFlexibleRedemptionRecord()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getFlexibleRewardsHistory()', () => {
        it('should execute getFlexibleRewardsHistory() successfully with required parameters only', async () => {
            const params: GetFlexibleRewardsHistoryRequest = {
                type: 'Bonus',
            };

            mockResponse = {
                rows: [
                    {
                        asset: 'BUSD',
                        rewards: '0.00006408',
                        projectId: 'USDT001',
                        type: 'BONUS',
                        time: 1577233578000,
                    },
                    {
                        asset: 'USDT',
                        rewards: '0.00687654',
                        projectId: 'USDT001',
                        type: 'REALTIME',
                        time: 1577233562000,
                    },
                ],
                total: 2,
            };

            const spy = jest.spyOn(client, 'getFlexibleRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleRewardsHistoryResponse>)
            );
            const response = await client.getFlexibleRewardsHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFlexibleRewardsHistory() successfully with optional parameters', async () => {
            const params: GetFlexibleRewardsHistoryRequest = {
                type: 'Bonus',
                productId: '1',
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        asset: 'BUSD',
                        rewards: '0.00006408',
                        projectId: 'USDT001',
                        type: 'BONUS',
                        time: 1577233578000,
                    },
                    {
                        asset: 'USDT',
                        rewards: '0.00687654',
                        projectId: 'USDT001',
                        type: 'REALTIME',
                        time: 1577233562000,
                    },
                ],
                total: 2,
            };

            const spy = jest.spyOn(client, 'getFlexibleRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleRewardsHistoryResponse>)
            );
            const response = await client.getFlexibleRewardsHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: GetFlexibleRewardsHistoryRequest = {
                type: 'Bonus',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.getFlexibleRewardsHistory(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling getFlexibleRewardsHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFlexibleRewardsHistoryRequest = {
                type: 'Bonus',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFlexibleRewardsHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFlexibleRewardsHistory(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getFlexibleSubscriptionRecord()', () => {
        it('should execute getFlexibleSubscriptionRecord() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        amount: '100.00000000',
                        asset: 'USDT',
                        time: 1575018510000,
                        purchaseId: 26055,
                        productId: 'USDT001',
                        type: 'AUTO',
                        sourceAccount: 'SPOT',
                        amtFromSpot: '30',
                        amtFromFunding: '70',
                        status: 'SUCCESS',
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getFlexibleSubscriptionRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleSubscriptionRecordResponse>)
            );
            const response = await client.getFlexibleSubscriptionRecord();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFlexibleSubscriptionRecord() successfully with optional parameters', async () => {
            const params: GetFlexibleSubscriptionRecordRequest = {
                productId: '1',
                purchaseId: '1',
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        amount: '100.00000000',
                        asset: 'USDT',
                        time: 1575018510000,
                        purchaseId: 26055,
                        productId: 'USDT001',
                        type: 'AUTO',
                        sourceAccount: 'SPOT',
                        amtFromSpot: '30',
                        amtFromFunding: '70',
                        status: 'SUCCESS',
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getFlexibleSubscriptionRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleSubscriptionRecordResponse>)
            );
            const response = await client.getFlexibleSubscriptionRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFlexibleSubscriptionRecord')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFlexibleSubscriptionRecord()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getLockedRedemptionRecord()', () => {
        it('should execute getLockedRedemptionRecord() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        positionId: 123123,
                        redeemId: 40607,
                        time: 1575018510000,
                        asset: 'BNB',
                        lockPeriod: '30',
                        amount: '21312.23223',
                        originalAmount: '21312.23223',
                        type: 'MATURE',
                        deliverDate: '1575018510000',
                        lossAmount: '0.00001232',
                        isComplete: true,
                        rewardAsset: 'AXS',
                        rewardAmt: '5.17181528',
                        extraRewardAsset: 'BNB',
                        estExtraRewardAmt: '5.17181528',
                        status: 'PAID',
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getLockedRedemptionRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedRedemptionRecordResponse>)
            );
            const response = await client.getLockedRedemptionRecord();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getLockedRedemptionRecord() successfully with optional parameters', async () => {
            const params: GetLockedRedemptionRecordRequest = {
                positionId: 1,
                redeemId: '1',
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        positionId: 123123,
                        redeemId: 40607,
                        time: 1575018510000,
                        asset: 'BNB',
                        lockPeriod: '30',
                        amount: '21312.23223',
                        originalAmount: '21312.23223',
                        type: 'MATURE',
                        deliverDate: '1575018510000',
                        lossAmount: '0.00001232',
                        isComplete: true,
                        rewardAsset: 'AXS',
                        rewardAmt: '5.17181528',
                        extraRewardAsset: 'BNB',
                        estExtraRewardAmt: '5.17181528',
                        status: 'PAID',
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getLockedRedemptionRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedRedemptionRecordResponse>)
            );
            const response = await client.getLockedRedemptionRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getLockedRedemptionRecord')
                .mockRejectedValueOnce(mockError);
            await expect(client.getLockedRedemptionRecord()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getLockedRewardsHistory()', () => {
        it('should execute getLockedRewardsHistory() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        positionId: 123123,
                        time: 1575018510000,
                        asset: 'BNB',
                        lockPeriod: '30',
                        amount: '21312.23223',
                        type: 'Locked Rewards',
                    },
                    {
                        positionId: '123123',
                        time: 1575018510000,
                        asset: 'BNB',
                        amount: '1.23223',
                        type: 'Boost Rewards',
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getLockedRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedRewardsHistoryResponse>)
            );
            const response = await client.getLockedRewardsHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getLockedRewardsHistory() successfully with optional parameters', async () => {
            const params: GetLockedRewardsHistoryRequest = {
                positionId: 1,
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        positionId: 123123,
                        time: 1575018510000,
                        asset: 'BNB',
                        lockPeriod: '30',
                        amount: '21312.23223',
                        type: 'Locked Rewards',
                    },
                    {
                        positionId: '123123',
                        time: 1575018510000,
                        asset: 'BNB',
                        amount: '1.23223',
                        type: 'Boost Rewards',
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getLockedRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedRewardsHistoryResponse>)
            );
            const response = await client.getLockedRewardsHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getLockedRewardsHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getLockedRewardsHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getLockedSubscriptionRecord()', () => {
        it('should execute getLockedSubscriptionRecord() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        positionId: 123123,
                        purchaseId: '26055',
                        projectId: 'Axs*90',
                        time: 1575018510000,
                        asset: 'BNB',
                        amount: '21312.23223',
                        lockPeriod: '30',
                        type: 'AUTO',
                        sourceAccount: 'SPOT',
                        amtFromSpot: '30',
                        amtFromFunding: '70',
                        status: 'SUCCESS',
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getLockedSubscriptionRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedSubscriptionRecordResponse>)
            );
            const response = await client.getLockedSubscriptionRecord();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getLockedSubscriptionRecord() successfully with optional parameters', async () => {
            const params: GetLockedSubscriptionRecordRequest = {
                purchaseId: '1',
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        positionId: 123123,
                        purchaseId: '26055',
                        projectId: 'Axs*90',
                        time: 1575018510000,
                        asset: 'BNB',
                        amount: '21312.23223',
                        lockPeriod: '30',
                        type: 'AUTO',
                        sourceAccount: 'SPOT',
                        amtFromSpot: '30',
                        amtFromFunding: '70',
                        status: 'SUCCESS',
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getLockedSubscriptionRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedSubscriptionRecordResponse>)
            );
            const response = await client.getLockedSubscriptionRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getLockedSubscriptionRecord')
                .mockRejectedValueOnce(mockError);
            await expect(client.getLockedSubscriptionRecord()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getRateHistory()', () => {
        it('should execute getRateHistory() successfully with required parameters only', async () => {
            const params: GetRateHistoryRequest = {
                productId: '1',
            };

            mockResponse = {
                rows: [
                    {
                        productId: 'BUSD001',
                        asset: 'BUSD',
                        annualPercentageRate: '0.00006408',
                        time: 1577233578000,
                    },
                ],
                total: '1',
            };

            const spy = jest.spyOn(client, 'getRateHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetRateHistoryResponse>)
            );
            const response = await client.getRateHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getRateHistory() successfully with optional parameters', async () => {
            const params: GetRateHistoryRequest = {
                productId: '1',
                aprPeriod: 'DAY',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        productId: 'BUSD001',
                        asset: 'BUSD',
                        annualPercentageRate: '0.00006408',
                        time: 1577233578000,
                    },
                ],
                total: '1',
            };

            const spy = jest.spyOn(client, 'getRateHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetRateHistoryResponse>)
            );
            const response = await client.getRateHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when productId is missing', async () => {
            const _params: GetRateHistoryRequest = {
                productId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.productId;

            await expect(client.getRateHistory(params)).rejects.toThrow(
                'Required parameter productId was null or undefined when calling getRateHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetRateHistoryRequest = {
                productId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getRateHistory').mockRejectedValueOnce(mockError);
            await expect(client.getRateHistory(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
