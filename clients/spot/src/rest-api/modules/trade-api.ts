/**
 * Binance Spot REST API
 *
 * OpenAPI Specifications for the Binance Spot REST API
 *
 * API documents:
 * - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
 * - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
    ConfigurationRestAPI,
    TimeUnit,
    RestApiResponse,
    assertParamExists,
    sendRequest,
    type RequestArgs,
} from '@binance/common';
import type {
    DeleteOpenOrdersResponse,
    DeleteOrderListResponse,
    DeleteOrderResponse,
    NewOrderResponse,
    OrderAmendKeepPriorityResponse,
    OrderCancelReplaceResponse,
    OrderListOcoResponse,
    OrderListOtoResponse,
    OrderListOtocoResponse,
    OrderOcoResponse,
    OrderTestResponse,
    SorOrderResponse,
    SorOrderTestResponse,
} from '../types';

/**
 * TradeApi - axios parameter creator
 */
const TradeApiAxiosParamCreator = function (configuration: ConfigurationRestAPI) {
    return {
        /**
         * Cancels all active orders on a symbol.
         * This includes orders that are part of an order list.
         * Weight: 1
         *
         * @summary Cancel All Open Orders on a Symbol
         * @param {string} symbol
         * @param {number} [recvWindow] The value cannot be greater than `60000`
         *
         * @throws {RequiredError}
         */
        deleteOpenOrders: async (symbol: string, recvWindow?: number): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteOpenOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/openOrders',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel an active order.
         * Weight: 1
         *
         * @summary Cancel order
         * @param {string} symbol
         * @param {number} [orderId]
         * @param {string} [origClientOrderId]
         * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
         * @param {DeleteOrderCancelRestrictionsEnum} [cancelRestrictions]
         * @param {number} [recvWindow] The value cannot be greater than `60000`
         *
         * @throws {RequiredError}
         */
        deleteOrder: async (
            symbol: string,
            orderId?: number,
            origClientOrderId?: string,
            newClientOrderId?: string,
            cancelRestrictions?: DeleteOrderCancelRestrictionsEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (cancelRestrictions !== undefined && cancelRestrictions !== null) {
                localVarQueryParameter['cancelRestrictions'] = cancelRestrictions;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/order',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel an entire Order list
         * Weight: 1
         *
         * @summary Cancel Order list
         * @param {string} symbol
         * @param {number} [orderListId] Either `orderListId` or `listClientOrderId` must be provided
         * @param {string} [listClientOrderId] A unique Id for the entire orderList
         * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
         * @param {number} [recvWindow] The value cannot be greater than `60000`
         *
         * @throws {RequiredError}
         */
        deleteOrderList: async (
            symbol: string,
            orderListId?: number,
            listClientOrderId?: string,
            newClientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteOrderList', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderListId !== undefined && orderListId !== null) {
                localVarQueryParameter['orderListId'] = orderListId;
            }

            if (listClientOrderId !== undefined && listClientOrderId !== null) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/orderList',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Send in a new order.
         *
         * This adds 1 order to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
         * Weight: 1
         *
         * @summary New order
         * @param {string} symbol
         * @param {NewOrderSideEnum} side
         * @param {NewOrderTypeEnum} type
         * @param {NewOrderTimeInForceEnum} [timeInForce]
         * @param {number} [quantity]
         * @param {number} [quoteOrderQty]
         * @param {number} [price]
         * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
         * @param {number} [strategyId]
         * @param {number} [strategyType] The value cannot be less than `1000000`.
         * @param {number} [stopPrice] Used with `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, and `TAKE_PROFIT_LIMIT` orders.
         * @param {number} [trailingDelta] See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
         * @param {number} [icebergQty] Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
         * @param {NewOrderNewOrderRespTypeEnum} [newOrderRespType]
         * @param {NewOrderSelfTradePreventionModeEnum} [selfTradePreventionMode]
         * @param {number} [recvWindow] The value cannot be greater than `60000`
         *
         * @throws {RequiredError}
         */
        newOrder: async (
            symbol: string,
            side: NewOrderSideEnum,
            type: NewOrderTypeEnum,
            timeInForce?: NewOrderTimeInForceEnum,
            quantity?: number,
            quoteOrderQty?: number,
            price?: number,
            newClientOrderId?: string,
            strategyId?: number,
            strategyType?: number,
            stopPrice?: number,
            trailingDelta?: number,
            icebergQty?: number,
            newOrderRespType?: NewOrderNewOrderRespTypeEnum,
            selfTradePreventionMode?: NewOrderSelfTradePreventionModeEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('newOrder', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('newOrder', 'side', side);
            // verify required parameter 'type' is not null or undefined
            assertParamExists('newOrder', 'type', type);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            if (timeInForce !== undefined && timeInForce !== null) {
                localVarQueryParameter['timeInForce'] = timeInForce;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (quoteOrderQty !== undefined && quoteOrderQty !== null) {
                localVarQueryParameter['quoteOrderQty'] = quoteOrderQty;
            }

            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }

            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (strategyId !== undefined && strategyId !== null) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (strategyType !== undefined && strategyType !== null) {
                localVarQueryParameter['strategyType'] = strategyType;
            }

            if (stopPrice !== undefined && stopPrice !== null) {
                localVarQueryParameter['stopPrice'] = stopPrice;
            }

            if (trailingDelta !== undefined && trailingDelta !== null) {
                localVarQueryParameter['trailingDelta'] = trailingDelta;
            }

            if (icebergQty !== undefined && icebergQty !== null) {
                localVarQueryParameter['icebergQty'] = icebergQty;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/order',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Reduce the quantity of an existing open order.
         *
         * This adds 0 orders to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
         *
         * Read [Order Amend Keep Priority FAQ](faqs/order_amend_keep_priority.md) to learn more.
         * Weight: 4
         *
         * @summary Order Amend Keep Priority
         * @param {string} symbol
         * @param {number} newQty `newQty` must be greater than 0 and less than the order's quantity.
         * @param {number} [orderId]
         * @param {string} [origClientOrderId]
         * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
         * @param {number} [recvWindow] The value cannot be greater than `60000`
         *
         * @throws {RequiredError}
         */
        orderAmendKeepPriority: async (
            symbol: string,
            newQty: number,
            orderId?: number,
            origClientOrderId?: string,
            newClientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('orderAmendKeepPriority', 'symbol', symbol);
            // verify required parameter 'newQty' is not null or undefined
            assertParamExists('orderAmendKeepPriority', 'newQty', newQty);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (newQty !== undefined && newQty !== null) {
                localVarQueryParameter['newQty'] = newQty;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/order/amend/keepPriority',
                method: 'PUT',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancels an existing order and places a new order on the same symbol.
         *
         * Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.
         *
         * A new order that was not attempted (i.e. when `newOrderResult: NOT_ATTEMPTED`), will still increase the unfilled order count by 1.
         * Weight: 1
         *
         * @summary Cancel an Existing Order and Send a New Order
         * @param {string} symbol
         * @param {OrderCancelReplaceSideEnum} side
         * @param {OrderCancelReplaceTypeEnum} type
         * @param {OrderCancelReplaceCancelReplaceModeEnum} cancelReplaceMode
         * @param {OrderCancelReplaceTimeInForceEnum} [timeInForce]
         * @param {number} [quantity]
         * @param {number} [quoteOrderQty]
         * @param {number} [price]
         * @param {string} [cancelNewClientOrderId] Used to uniquely identify this cancel. Automatically generated by default.
         * @param {string} [cancelOrigClientOrderId] Either `cancelOrderId` or `cancelOrigClientOrderId` must be sent. <br></br> If both `cancelOrderId` and `cancelOrigClientOrderId` parameters are provided, the `cancelOrderId` is searched first, then the `cancelOrigClientOrderId` from that result is checked against that order. <br></br> If both conditions are not met the request will be rejected.
         * @param {number} [cancelOrderId] Either `cancelOrderId` or `cancelOrigClientOrderId` must be sent. <br></br>If both `cancelOrderId` and `cancelOrigClientOrderId` parameters are provided, the `cancelOrderId` is searched first, then the `cancelOrigClientOrderId` from that result is checked against that order. <br></br>If both conditions are not met the request will be rejected.
         * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
         * @param {number} [strategyId]
         * @param {number} [strategyType] The value cannot be less than `1000000`.
         * @param {number} [stopPrice] Used with `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, and `TAKE_PROFIT_LIMIT` orders.
         * @param {number} [trailingDelta] See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
         * @param {number} [icebergQty] Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
         * @param {OrderCancelReplaceNewOrderRespTypeEnum} [newOrderRespType]
         * @param {OrderCancelReplaceSelfTradePreventionModeEnum} [selfTradePreventionMode]
         * @param {OrderCancelReplaceCancelRestrictionsEnum} [cancelRestrictions]
         * @param {OrderCancelReplaceOrderRateLimitExceededModeEnum} [orderRateLimitExceededMode]
         * @param {number} [recvWindow] The value cannot be greater than `60000`
         *
         * @throws {RequiredError}
         */
        orderCancelReplace: async (
            symbol: string,
            side: OrderCancelReplaceSideEnum,
            type: OrderCancelReplaceTypeEnum,
            cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum,
            timeInForce?: OrderCancelReplaceTimeInForceEnum,
            quantity?: number,
            quoteOrderQty?: number,
            price?: number,
            cancelNewClientOrderId?: string,
            cancelOrigClientOrderId?: string,
            cancelOrderId?: number,
            newClientOrderId?: string,
            strategyId?: number,
            strategyType?: number,
            stopPrice?: number,
            trailingDelta?: number,
            icebergQty?: number,
            newOrderRespType?: OrderCancelReplaceNewOrderRespTypeEnum,
            selfTradePreventionMode?: OrderCancelReplaceSelfTradePreventionModeEnum,
            cancelRestrictions?: OrderCancelReplaceCancelRestrictionsEnum,
            orderRateLimitExceededMode?: OrderCancelReplaceOrderRateLimitExceededModeEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('orderCancelReplace', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('orderCancelReplace', 'side', side);
            // verify required parameter 'type' is not null or undefined
            assertParamExists('orderCancelReplace', 'type', type);
            // verify required parameter 'cancelReplaceMode' is not null or undefined
            assertParamExists('orderCancelReplace', 'cancelReplaceMode', cancelReplaceMode);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            if (cancelReplaceMode !== undefined && cancelReplaceMode !== null) {
                localVarQueryParameter['cancelReplaceMode'] = cancelReplaceMode;
            }

            if (timeInForce !== undefined && timeInForce !== null) {
                localVarQueryParameter['timeInForce'] = timeInForce;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (quoteOrderQty !== undefined && quoteOrderQty !== null) {
                localVarQueryParameter['quoteOrderQty'] = quoteOrderQty;
            }

            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }

            if (cancelNewClientOrderId !== undefined && cancelNewClientOrderId !== null) {
                localVarQueryParameter['cancelNewClientOrderId'] = cancelNewClientOrderId;
            }

            if (cancelOrigClientOrderId !== undefined && cancelOrigClientOrderId !== null) {
                localVarQueryParameter['cancelOrigClientOrderId'] = cancelOrigClientOrderId;
            }

            if (cancelOrderId !== undefined && cancelOrderId !== null) {
                localVarQueryParameter['cancelOrderId'] = cancelOrderId;
            }

            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (strategyId !== undefined && strategyId !== null) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (strategyType !== undefined && strategyType !== null) {
                localVarQueryParameter['strategyType'] = strategyType;
            }

            if (stopPrice !== undefined && stopPrice !== null) {
                localVarQueryParameter['stopPrice'] = stopPrice;
            }

            if (trailingDelta !== undefined && trailingDelta !== null) {
                localVarQueryParameter['trailingDelta'] = trailingDelta;
            }

            if (icebergQty !== undefined && icebergQty !== null) {
                localVarQueryParameter['icebergQty'] = icebergQty;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (cancelRestrictions !== undefined && cancelRestrictions !== null) {
                localVarQueryParameter['cancelRestrictions'] = cancelRestrictions;
            }

            if (orderRateLimitExceededMode !== undefined && orderRateLimitExceededMode !== null) {
                localVarQueryParameter['orderRateLimitExceededMode'] = orderRateLimitExceededMode;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/order/cancelReplace',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other.
         *
         * An OCO has 2 orders called the **above order** and **below order**.
         * One of the orders must be a `LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT` order and the other must be `STOP_LOSS` or `STOP_LOSS_LIMIT` order.
         * Price restrictions
         * If the OCO is on the `SELL` side:
         * `LIMIT_MAKER/TAKE_PROFIT_LIMIT` `price` > Last Traded Price >  `STOP_LOSS/STOP_LOSS_LIMIT` `stopPrice`
         * `TAKE_PROFIT stopPrice` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
         * If the OCO is on the `BUY` side:
         * `LIMIT_MAKER/TAKE_PROFIT_LIMIT price` < Last Traded Price < `stopPrice`
         * `TAKE_PROFIT stopPrice` < Last Traded Price < `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
         * OCOs add **2 orders** to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
         * Weight: 1
         *
         * Unfilled Order Count: 2
         *
         * @summary New Order list - OCO
         * @param {string} symbol
         * @param {OrderListOcoSideEnum} side
         * @param {number} quantity
         * @param {OrderListOcoAboveTypeEnum} aboveType
         * @param {OrderListOcoBelowTypeEnum} belowType
         * @param {string} [listClientOrderId] A unique Id for the entire orderList
         * @param {string} [aboveClientOrderId] Arbitrary unique ID among open orders for the above order. Automatically generated if not sent
         * @param {number} [aboveIcebergQty] Note that this can only be used if `aboveTimeInForce` is `GTC`.
         * @param {number} [abovePrice] Can be used if `aboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
         * @param {number} [aboveStopPrice] Can be used if `aboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT`. <br>Either `aboveStopPrice` or `aboveTrailingDelta` or both, must be specified.
         * @param {number} [aboveTrailingDelta] See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
         * @param {number} [aboveTimeInForce] Required if `aboveType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT`
         * @param {number} [aboveStrategyId] Arbitrary numeric value identifying the above order within an order strategy.
         * @param {number} [aboveStrategyType] Arbitrary numeric value identifying the above order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
         * @param {string} [belowClientOrderId] Arbitrary unique ID among open orders for the below order. Automatically generated if not sent
         * @param {number} [belowIcebergQty] Note that this can only be used if `belowTimeInForce` is `GTC`.
         * @param {number} [belowPrice] Can be used if `belowType` is `STOP_LOSS_LIMIT`, `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
         * @param {number} [belowStopPrice] Can be used if `belowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT, TAKE_PROFIT` or `TAKE_PROFIT_LIMIT` <br>Either belowStopPrice or belowTrailingDelta or both, must be specified.
         * @param {number} [belowTrailingDelta] See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
         * @param {OrderListOcoBelowTimeInForceEnum} [belowTimeInForce]
         * @param {number} [belowStrategyId] Arbitrary numeric value identifying the below order within an order strategy.
         * @param {number} [belowStrategyType] Arbitrary numeric value identifying the below order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
         * @param {OrderListOcoNewOrderRespTypeEnum} [newOrderRespType]
         * @param {OrderListOcoSelfTradePreventionModeEnum} [selfTradePreventionMode]
         * @param {number} [recvWindow] The value cannot be greater than `60000`
         *
         * @throws {RequiredError}
         */
        orderListOco: async (
            symbol: string,
            side: OrderListOcoSideEnum,
            quantity: number,
            aboveType: OrderListOcoAboveTypeEnum,
            belowType: OrderListOcoBelowTypeEnum,
            listClientOrderId?: string,
            aboveClientOrderId?: string,
            aboveIcebergQty?: number,
            abovePrice?: number,
            aboveStopPrice?: number,
            aboveTrailingDelta?: number,
            aboveTimeInForce?: number,
            aboveStrategyId?: number,
            aboveStrategyType?: number,
            belowClientOrderId?: string,
            belowIcebergQty?: number,
            belowPrice?: number,
            belowStopPrice?: number,
            belowTrailingDelta?: number,
            belowTimeInForce?: OrderListOcoBelowTimeInForceEnum,
            belowStrategyId?: number,
            belowStrategyType?: number,
            newOrderRespType?: OrderListOcoNewOrderRespTypeEnum,
            selfTradePreventionMode?: OrderListOcoSelfTradePreventionModeEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('orderListOco', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('orderListOco', 'side', side);
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('orderListOco', 'quantity', quantity);
            // verify required parameter 'aboveType' is not null or undefined
            assertParamExists('orderListOco', 'aboveType', aboveType);
            // verify required parameter 'belowType' is not null or undefined
            assertParamExists('orderListOco', 'belowType', belowType);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (listClientOrderId !== undefined && listClientOrderId !== null) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (aboveType !== undefined && aboveType !== null) {
                localVarQueryParameter['aboveType'] = aboveType;
            }

            if (aboveClientOrderId !== undefined && aboveClientOrderId !== null) {
                localVarQueryParameter['aboveClientOrderId'] = aboveClientOrderId;
            }

            if (aboveIcebergQty !== undefined && aboveIcebergQty !== null) {
                localVarQueryParameter['aboveIcebergQty'] = aboveIcebergQty;
            }

            if (abovePrice !== undefined && abovePrice !== null) {
                localVarQueryParameter['abovePrice'] = abovePrice;
            }

            if (aboveStopPrice !== undefined && aboveStopPrice !== null) {
                localVarQueryParameter['aboveStopPrice'] = aboveStopPrice;
            }

            if (aboveTrailingDelta !== undefined && aboveTrailingDelta !== null) {
                localVarQueryParameter['aboveTrailingDelta'] = aboveTrailingDelta;
            }

            if (aboveTimeInForce !== undefined && aboveTimeInForce !== null) {
                localVarQueryParameter['aboveTimeInForce'] = aboveTimeInForce;
            }

            if (aboveStrategyId !== undefined && aboveStrategyId !== null) {
                localVarQueryParameter['aboveStrategyId'] = aboveStrategyId;
            }

            if (aboveStrategyType !== undefined && aboveStrategyType !== null) {
                localVarQueryParameter['aboveStrategyType'] = aboveStrategyType;
            }

            if (belowType !== undefined && belowType !== null) {
                localVarQueryParameter['belowType'] = belowType;
            }

            if (belowClientOrderId !== undefined && belowClientOrderId !== null) {
                localVarQueryParameter['belowClientOrderId'] = belowClientOrderId;
            }

            if (belowIcebergQty !== undefined && belowIcebergQty !== null) {
                localVarQueryParameter['belowIcebergQty'] = belowIcebergQty;
            }

            if (belowPrice !== undefined && belowPrice !== null) {
                localVarQueryParameter['belowPrice'] = belowPrice;
            }

            if (belowStopPrice !== undefined && belowStopPrice !== null) {
                localVarQueryParameter['belowStopPrice'] = belowStopPrice;
            }

            if (belowTrailingDelta !== undefined && belowTrailingDelta !== null) {
                localVarQueryParameter['belowTrailingDelta'] = belowTrailingDelta;
            }

            if (belowTimeInForce !== undefined && belowTimeInForce !== null) {
                localVarQueryParameter['belowTimeInForce'] = belowTimeInForce;
            }

            if (belowStrategyId !== undefined && belowStrategyId !== null) {
                localVarQueryParameter['belowStrategyId'] = belowStrategyId;
            }

            if (belowStrategyType !== undefined && belowStrategyType !== null) {
                localVarQueryParameter['belowStrategyType'] = belowStrategyType;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/orderList/oco',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Place an OTO.
         *
         * An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
         * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
         * The second order is called the **pending order**. It can be any order type except for `MARKET` orders using parameter `quoteOrderQty`. The pending order is only placed on the order book when the working order gets **fully filled**.
         * If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
         * When the order list is placed, if the working order gets **immediately fully filled**, the placement response will show the working order as `FILLED` but the pending order will still appear as `PENDING_NEW`. You need to query the status of the pending order again to see its updated status.
         * OTOs add **2 orders** to the `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
         * Weight: 1
         *
         * Unfilled Order Count: 2
         *
         * @summary New Order list - OTO
         * @param {string} symbol
         * @param {OrderListOtoWorkingTypeEnum} workingType
         * @param {OrderListOtoWorkingSideEnum} workingSide
         * @param {number} workingPrice
         * @param {number} workingQuantity Sets the quantity for the working order.
         * @param {OrderListOtoPendingTypeEnum} pendingType
         * @param {OrderListOtoPendingSideEnum} pendingSide
         * @param {number} pendingQuantity Sets the quantity for the pending order.
         * @param {string} [listClientOrderId] A unique Id for the entire orderList
         * @param {OrderListOtoNewOrderRespTypeEnum} [newOrderRespType]
         * @param {OrderListOtoSelfTradePreventionModeEnum} [selfTradePreventionMode]
         * @param {string} [workingClientOrderId] Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
         * @param {number} [workingIcebergQty] This can only be used if `workingTimeInForce` is `GTC`, or if `workingType` is `LIMIT_MAKER`.
         * @param {OrderListOtoWorkingTimeInForceEnum} [workingTimeInForce]
         * @param {number} [workingStrategyId] Arbitrary numeric value identifying the working order within an order strategy.
         * @param {number} [workingStrategyType] Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
         * @param {string} [pendingClientOrderId] Arbitrary unique ID among open orders for the pending order.<br> Automatically generated if not sent.
         * @param {number} [pendingPrice]
         * @param {number} [pendingStopPrice]
         * @param {number} [pendingTrailingDelta]
         * @param {number} [pendingIcebergQty] This can only be used if `pendingTimeInForce` is `GTC` or if `pendingType` is `LIMIT_MAKER`.
         * @param {OrderListOtoPendingTimeInForceEnum} [pendingTimeInForce]
         * @param {number} [pendingStrategyId] Arbitrary numeric value identifying the pending order within an order strategy.
         * @param {number} [pendingStrategyType] Arbitrary numeric value identifying the pending order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
         * @param {number} [recvWindow] The value cannot be greater than `60000`
         *
         * @throws {RequiredError}
         */
        orderListOto: async (
            symbol: string,
            workingType: OrderListOtoWorkingTypeEnum,
            workingSide: OrderListOtoWorkingSideEnum,
            workingPrice: number,
            workingQuantity: number,
            pendingType: OrderListOtoPendingTypeEnum,
            pendingSide: OrderListOtoPendingSideEnum,
            pendingQuantity: number,
            listClientOrderId?: string,
            newOrderRespType?: OrderListOtoNewOrderRespTypeEnum,
            selfTradePreventionMode?: OrderListOtoSelfTradePreventionModeEnum,
            workingClientOrderId?: string,
            workingIcebergQty?: number,
            workingTimeInForce?: OrderListOtoWorkingTimeInForceEnum,
            workingStrategyId?: number,
            workingStrategyType?: number,
            pendingClientOrderId?: string,
            pendingPrice?: number,
            pendingStopPrice?: number,
            pendingTrailingDelta?: number,
            pendingIcebergQty?: number,
            pendingTimeInForce?: OrderListOtoPendingTimeInForceEnum,
            pendingStrategyId?: number,
            pendingStrategyType?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('orderListOto', 'symbol', symbol);
            // verify required parameter 'workingType' is not null or undefined
            assertParamExists('orderListOto', 'workingType', workingType);
            // verify required parameter 'workingSide' is not null or undefined
            assertParamExists('orderListOto', 'workingSide', workingSide);
            // verify required parameter 'workingPrice' is not null or undefined
            assertParamExists('orderListOto', 'workingPrice', workingPrice);
            // verify required parameter 'workingQuantity' is not null or undefined
            assertParamExists('orderListOto', 'workingQuantity', workingQuantity);
            // verify required parameter 'pendingType' is not null or undefined
            assertParamExists('orderListOto', 'pendingType', pendingType);
            // verify required parameter 'pendingSide' is not null or undefined
            assertParamExists('orderListOto', 'pendingSide', pendingSide);
            // verify required parameter 'pendingQuantity' is not null or undefined
            assertParamExists('orderListOto', 'pendingQuantity', pendingQuantity);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (listClientOrderId !== undefined && listClientOrderId !== null) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (workingType !== undefined && workingType !== null) {
                localVarQueryParameter['workingType'] = workingType;
            }

            if (workingSide !== undefined && workingSide !== null) {
                localVarQueryParameter['workingSide'] = workingSide;
            }

            if (workingClientOrderId !== undefined && workingClientOrderId !== null) {
                localVarQueryParameter['workingClientOrderId'] = workingClientOrderId;
            }

            if (workingPrice !== undefined && workingPrice !== null) {
                localVarQueryParameter['workingPrice'] = workingPrice;
            }

            if (workingQuantity !== undefined && workingQuantity !== null) {
                localVarQueryParameter['workingQuantity'] = workingQuantity;
            }

            if (workingIcebergQty !== undefined && workingIcebergQty !== null) {
                localVarQueryParameter['workingIcebergQty'] = workingIcebergQty;
            }

            if (workingTimeInForce !== undefined && workingTimeInForce !== null) {
                localVarQueryParameter['workingTimeInForce'] = workingTimeInForce;
            }

            if (workingStrategyId !== undefined && workingStrategyId !== null) {
                localVarQueryParameter['workingStrategyId'] = workingStrategyId;
            }

            if (workingStrategyType !== undefined && workingStrategyType !== null) {
                localVarQueryParameter['workingStrategyType'] = workingStrategyType;
            }

            if (pendingType !== undefined && pendingType !== null) {
                localVarQueryParameter['pendingType'] = pendingType;
            }

            if (pendingSide !== undefined && pendingSide !== null) {
                localVarQueryParameter['pendingSide'] = pendingSide;
            }

            if (pendingClientOrderId !== undefined && pendingClientOrderId !== null) {
                localVarQueryParameter['pendingClientOrderId'] = pendingClientOrderId;
            }

            if (pendingPrice !== undefined && pendingPrice !== null) {
                localVarQueryParameter['pendingPrice'] = pendingPrice;
            }

            if (pendingStopPrice !== undefined && pendingStopPrice !== null) {
                localVarQueryParameter['pendingStopPrice'] = pendingStopPrice;
            }

            if (pendingTrailingDelta !== undefined && pendingTrailingDelta !== null) {
                localVarQueryParameter['pendingTrailingDelta'] = pendingTrailingDelta;
            }

            if (pendingQuantity !== undefined && pendingQuantity !== null) {
                localVarQueryParameter['pendingQuantity'] = pendingQuantity;
            }

            if (pendingIcebergQty !== undefined && pendingIcebergQty !== null) {
                localVarQueryParameter['pendingIcebergQty'] = pendingIcebergQty;
            }

            if (pendingTimeInForce !== undefined && pendingTimeInForce !== null) {
                localVarQueryParameter['pendingTimeInForce'] = pendingTimeInForce;
            }

            if (pendingStrategyId !== undefined && pendingStrategyId !== null) {
                localVarQueryParameter['pendingStrategyId'] = pendingStrategyId;
            }

            if (pendingStrategyType !== undefined && pendingStrategyType !== null) {
                localVarQueryParameter['pendingStrategyType'] = pendingStrategyType;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/orderList/oto',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Place an OTOCO.
         *
         * An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
         * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
         * The behavior of the working order is the same as the [OTO](#new-order-list---oto-trade).
         * OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets **fully filled**.
         * The rules of the pending above and pending below follow the same rules as the [Order list OCO](#new-order-list---oco-trade).
         * OTOCOs add **3 orders** to the `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
         * Weight: 1
         *
         * Unfilled Order Count: 3
         *
         * @summary New Order list - OTOCO
         * @param {string} symbol
         * @param {OrderListOtocoWorkingTypeEnum} workingType
         * @param {OrderListOtocoWorkingSideEnum} workingSide
         * @param {number} workingPrice
         * @param {number} workingQuantity Sets the quantity for the working order.
         * @param {OrderListOtocoPendingSideEnum} pendingSide
         * @param {number} pendingQuantity Sets the quantity for the pending order.
         * @param {OrderListOtocoPendingAboveTypeEnum} pendingAboveType
         * @param {string} [listClientOrderId] A unique Id for the entire orderList
         * @param {OrderListOtocoNewOrderRespTypeEnum} [newOrderRespType]
         * @param {OrderListOtocoSelfTradePreventionModeEnum} [selfTradePreventionMode]
         * @param {string} [workingClientOrderId] Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
         * @param {number} [workingIcebergQty] This can only be used if `workingTimeInForce` is `GTC`, or if `workingType` is `LIMIT_MAKER`.
         * @param {OrderListOtocoWorkingTimeInForceEnum} [workingTimeInForce]
         * @param {number} [workingStrategyId] Arbitrary numeric value identifying the working order within an order strategy.
         * @param {number} [workingStrategyType] Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
         * @param {string} [pendingAboveClientOrderId] Arbitrary unique ID among open orders for the pending above order.<br> Automatically generated if not sent.
         * @param {number} [pendingAbovePrice] Can be used if `pendingAboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
         * @param {number} [pendingAboveStopPrice] Can be used if `pendingAboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT`
         * @param {number} [pendingAboveTrailingDelta] See [Trailing Stop FAQ](faqs/trailing-stop-faq.md)
         * @param {number} [pendingAboveIcebergQty] This can only be used if `pendingAboveTimeInForce` is `GTC` or if `pendingAboveType` is `LIMIT_MAKER`.
         * @param {OrderListOtocoPendingAboveTimeInForceEnum} [pendingAboveTimeInForce]
         * @param {number} [pendingAboveStrategyId] Arbitrary numeric value identifying the pending above order within an order strategy.
         * @param {number} [pendingAboveStrategyType] Arbitrary numeric value identifying the pending above order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
         * @param {OrderListOtocoPendingBelowTypeEnum} [pendingBelowType]
         * @param {string} [pendingBelowClientOrderId] Arbitrary unique ID among open orders for the pending below order.<br> Automatically generated if not sent.
         * @param {number} [pendingBelowPrice] Can be used if `pendingBelowType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT` to specify limit price
         * @param {number} [pendingBelowStopPrice] Can be used if `pendingBelowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT, TAKE_PROFIT or TAKE_PROFIT_LIMIT`. <br>Either `pendingBelowStopPrice` or `pendingBelowTrailingDelta` or both, must be specified.
         * @param {number} [pendingBelowTrailingDelta]
         * @param {number} [pendingBelowIcebergQty] This can only be used if `pendingBelowTimeInForce` is `GTC`, or if `pendingBelowType` is `LIMIT_MAKER`.
         * @param {OrderListOtocoPendingBelowTimeInForceEnum} [pendingBelowTimeInForce]
         * @param {number} [pendingBelowStrategyId] Arbitrary numeric value identifying the pending below order within an order strategy.
         * @param {number} [pendingBelowStrategyType] Arbitrary numeric value identifying the pending below order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
         * @param {number} [recvWindow] The value cannot be greater than `60000`
         *
         * @throws {RequiredError}
         */
        orderListOtoco: async (
            symbol: string,
            workingType: OrderListOtocoWorkingTypeEnum,
            workingSide: OrderListOtocoWorkingSideEnum,
            workingPrice: number,
            workingQuantity: number,
            pendingSide: OrderListOtocoPendingSideEnum,
            pendingQuantity: number,
            pendingAboveType: OrderListOtocoPendingAboveTypeEnum,
            listClientOrderId?: string,
            newOrderRespType?: OrderListOtocoNewOrderRespTypeEnum,
            selfTradePreventionMode?: OrderListOtocoSelfTradePreventionModeEnum,
            workingClientOrderId?: string,
            workingIcebergQty?: number,
            workingTimeInForce?: OrderListOtocoWorkingTimeInForceEnum,
            workingStrategyId?: number,
            workingStrategyType?: number,
            pendingAboveClientOrderId?: string,
            pendingAbovePrice?: number,
            pendingAboveStopPrice?: number,
            pendingAboveTrailingDelta?: number,
            pendingAboveIcebergQty?: number,
            pendingAboveTimeInForce?: OrderListOtocoPendingAboveTimeInForceEnum,
            pendingAboveStrategyId?: number,
            pendingAboveStrategyType?: number,
            pendingBelowType?: OrderListOtocoPendingBelowTypeEnum,
            pendingBelowClientOrderId?: string,
            pendingBelowPrice?: number,
            pendingBelowStopPrice?: number,
            pendingBelowTrailingDelta?: number,
            pendingBelowIcebergQty?: number,
            pendingBelowTimeInForce?: OrderListOtocoPendingBelowTimeInForceEnum,
            pendingBelowStrategyId?: number,
            pendingBelowStrategyType?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('orderListOtoco', 'symbol', symbol);
            // verify required parameter 'workingType' is not null or undefined
            assertParamExists('orderListOtoco', 'workingType', workingType);
            // verify required parameter 'workingSide' is not null or undefined
            assertParamExists('orderListOtoco', 'workingSide', workingSide);
            // verify required parameter 'workingPrice' is not null or undefined
            assertParamExists('orderListOtoco', 'workingPrice', workingPrice);
            // verify required parameter 'workingQuantity' is not null or undefined
            assertParamExists('orderListOtoco', 'workingQuantity', workingQuantity);
            // verify required parameter 'pendingSide' is not null or undefined
            assertParamExists('orderListOtoco', 'pendingSide', pendingSide);
            // verify required parameter 'pendingQuantity' is not null or undefined
            assertParamExists('orderListOtoco', 'pendingQuantity', pendingQuantity);
            // verify required parameter 'pendingAboveType' is not null or undefined
            assertParamExists('orderListOtoco', 'pendingAboveType', pendingAboveType);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (listClientOrderId !== undefined && listClientOrderId !== null) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (workingType !== undefined && workingType !== null) {
                localVarQueryParameter['workingType'] = workingType;
            }

            if (workingSide !== undefined && workingSide !== null) {
                localVarQueryParameter['workingSide'] = workingSide;
            }

            if (workingClientOrderId !== undefined && workingClientOrderId !== null) {
                localVarQueryParameter['workingClientOrderId'] = workingClientOrderId;
            }

            if (workingPrice !== undefined && workingPrice !== null) {
                localVarQueryParameter['workingPrice'] = workingPrice;
            }

            if (workingQuantity !== undefined && workingQuantity !== null) {
                localVarQueryParameter['workingQuantity'] = workingQuantity;
            }

            if (workingIcebergQty !== undefined && workingIcebergQty !== null) {
                localVarQueryParameter['workingIcebergQty'] = workingIcebergQty;
            }

            if (workingTimeInForce !== undefined && workingTimeInForce !== null) {
                localVarQueryParameter['workingTimeInForce'] = workingTimeInForce;
            }

            if (workingStrategyId !== undefined && workingStrategyId !== null) {
                localVarQueryParameter['workingStrategyId'] = workingStrategyId;
            }

            if (workingStrategyType !== undefined && workingStrategyType !== null) {
                localVarQueryParameter['workingStrategyType'] = workingStrategyType;
            }

            if (pendingSide !== undefined && pendingSide !== null) {
                localVarQueryParameter['pendingSide'] = pendingSide;
            }

            if (pendingQuantity !== undefined && pendingQuantity !== null) {
                localVarQueryParameter['pendingQuantity'] = pendingQuantity;
            }

            if (pendingAboveType !== undefined && pendingAboveType !== null) {
                localVarQueryParameter['pendingAboveType'] = pendingAboveType;
            }

            if (pendingAboveClientOrderId !== undefined && pendingAboveClientOrderId !== null) {
                localVarQueryParameter['pendingAboveClientOrderId'] = pendingAboveClientOrderId;
            }

            if (pendingAbovePrice !== undefined && pendingAbovePrice !== null) {
                localVarQueryParameter['pendingAbovePrice'] = pendingAbovePrice;
            }

            if (pendingAboveStopPrice !== undefined && pendingAboveStopPrice !== null) {
                localVarQueryParameter['pendingAboveStopPrice'] = pendingAboveStopPrice;
            }

            if (pendingAboveTrailingDelta !== undefined && pendingAboveTrailingDelta !== null) {
                localVarQueryParameter['pendingAboveTrailingDelta'] = pendingAboveTrailingDelta;
            }

            if (pendingAboveIcebergQty !== undefined && pendingAboveIcebergQty !== null) {
                localVarQueryParameter['pendingAboveIcebergQty'] = pendingAboveIcebergQty;
            }

            if (pendingAboveTimeInForce !== undefined && pendingAboveTimeInForce !== null) {
                localVarQueryParameter['pendingAboveTimeInForce'] = pendingAboveTimeInForce;
            }

            if (pendingAboveStrategyId !== undefined && pendingAboveStrategyId !== null) {
                localVarQueryParameter['pendingAboveStrategyId'] = pendingAboveStrategyId;
            }

            if (pendingAboveStrategyType !== undefined && pendingAboveStrategyType !== null) {
                localVarQueryParameter['pendingAboveStrategyType'] = pendingAboveStrategyType;
            }

            if (pendingBelowType !== undefined && pendingBelowType !== null) {
                localVarQueryParameter['pendingBelowType'] = pendingBelowType;
            }

            if (pendingBelowClientOrderId !== undefined && pendingBelowClientOrderId !== null) {
                localVarQueryParameter['pendingBelowClientOrderId'] = pendingBelowClientOrderId;
            }

            if (pendingBelowPrice !== undefined && pendingBelowPrice !== null) {
                localVarQueryParameter['pendingBelowPrice'] = pendingBelowPrice;
            }

            if (pendingBelowStopPrice !== undefined && pendingBelowStopPrice !== null) {
                localVarQueryParameter['pendingBelowStopPrice'] = pendingBelowStopPrice;
            }

            if (pendingBelowTrailingDelta !== undefined && pendingBelowTrailingDelta !== null) {
                localVarQueryParameter['pendingBelowTrailingDelta'] = pendingBelowTrailingDelta;
            }

            if (pendingBelowIcebergQty !== undefined && pendingBelowIcebergQty !== null) {
                localVarQueryParameter['pendingBelowIcebergQty'] = pendingBelowIcebergQty;
            }

            if (pendingBelowTimeInForce !== undefined && pendingBelowTimeInForce !== null) {
                localVarQueryParameter['pendingBelowTimeInForce'] = pendingBelowTimeInForce;
            }

            if (pendingBelowStrategyId !== undefined && pendingBelowStrategyId !== null) {
                localVarQueryParameter['pendingBelowStrategyId'] = pendingBelowStrategyId;
            }

            if (pendingBelowStrategyType !== undefined && pendingBelowStrategyType !== null) {
                localVarQueryParameter['pendingBelowStrategyType'] = pendingBelowStrategyType;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/orderList/otoco',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Send in a new OCO.
         *
         * Price Restrictions:
         * `SELL`: Limit Price > Last Price > Stop Price
         * `BUY`: Limit Price < Last Price < Stop Price
         * Quantity Restrictions:
         * Both legs must have the same quantity.
         * `ICEBERG` quantities however do not have to be the same
         * `OCO` adds **2 orders** to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
         * Weight: 1
         *
         * Unfilled Order Count: 2
         *
         * @summary New OCO - Deprecated
         * @param {string} symbol
         * @param {OrderOcoSideEnum} side
         * @param {number} quantity
         * @param {number} price
         * @param {number} stopPrice
         * @param {string} [listClientOrderId] A unique Id for the entire orderList
         * @param {string} [limitClientOrderId] A unique Id for the limit order
         * @param {number} [limitStrategyId]
         * @param {number} [limitStrategyType] The value cannot be less than `1000000`.
         * @param {number} [limitIcebergQty] Used to make the `LIMIT_MAKER` leg an iceberg order.
         * @param {number} [trailingDelta] See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
         * @param {string} [stopClientOrderId] A unique Id for the stop loss/stop loss limit leg
         * @param {number} [stopStrategyId]
         * @param {number} [stopStrategyType] The value cannot be less than `1000000`.
         * @param {number} [stopLimitPrice] If provided, `stopLimitTimeInForce` is required.
         * @param {number} [stopIcebergQty] Used with `STOP_LOSS_LIMIT` leg to make an iceberg order.
         * @param {OrderOcoStopLimitTimeInForceEnum} [stopLimitTimeInForce]
         * @param {OrderOcoNewOrderRespTypeEnum} [newOrderRespType]
         * @param {OrderOcoSelfTradePreventionModeEnum} [selfTradePreventionMode]
         * @param {number} [recvWindow] The value cannot be greater than `60000`
         *
         * @throws {RequiredError}
         */
        orderOco: async (
            symbol: string,
            side: OrderOcoSideEnum,
            quantity: number,
            price: number,
            stopPrice: number,
            listClientOrderId?: string,
            limitClientOrderId?: string,
            limitStrategyId?: number,
            limitStrategyType?: number,
            limitIcebergQty?: number,
            trailingDelta?: number,
            stopClientOrderId?: string,
            stopStrategyId?: number,
            stopStrategyType?: number,
            stopLimitPrice?: number,
            stopIcebergQty?: number,
            stopLimitTimeInForce?: OrderOcoStopLimitTimeInForceEnum,
            newOrderRespType?: OrderOcoNewOrderRespTypeEnum,
            selfTradePreventionMode?: OrderOcoSelfTradePreventionModeEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('orderOco', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('orderOco', 'side', side);
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('orderOco', 'quantity', quantity);
            // verify required parameter 'price' is not null or undefined
            assertParamExists('orderOco', 'price', price);
            // verify required parameter 'stopPrice' is not null or undefined
            assertParamExists('orderOco', 'stopPrice', stopPrice);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (listClientOrderId !== undefined && listClientOrderId !== null) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (limitClientOrderId !== undefined && limitClientOrderId !== null) {
                localVarQueryParameter['limitClientOrderId'] = limitClientOrderId;
            }

            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }

            if (limitStrategyId !== undefined && limitStrategyId !== null) {
                localVarQueryParameter['limitStrategyId'] = limitStrategyId;
            }

            if (limitStrategyType !== undefined && limitStrategyType !== null) {
                localVarQueryParameter['limitStrategyType'] = limitStrategyType;
            }

            if (limitIcebergQty !== undefined && limitIcebergQty !== null) {
                localVarQueryParameter['limitIcebergQty'] = limitIcebergQty;
            }

            if (trailingDelta !== undefined && trailingDelta !== null) {
                localVarQueryParameter['trailingDelta'] = trailingDelta;
            }

            if (stopClientOrderId !== undefined && stopClientOrderId !== null) {
                localVarQueryParameter['stopClientOrderId'] = stopClientOrderId;
            }

            if (stopPrice !== undefined && stopPrice !== null) {
                localVarQueryParameter['stopPrice'] = stopPrice;
            }

            if (stopStrategyId !== undefined && stopStrategyId !== null) {
                localVarQueryParameter['stopStrategyId'] = stopStrategyId;
            }

            if (stopStrategyType !== undefined && stopStrategyType !== null) {
                localVarQueryParameter['stopStrategyType'] = stopStrategyType;
            }

            if (stopLimitPrice !== undefined && stopLimitPrice !== null) {
                localVarQueryParameter['stopLimitPrice'] = stopLimitPrice;
            }

            if (stopIcebergQty !== undefined && stopIcebergQty !== null) {
                localVarQueryParameter['stopIcebergQty'] = stopIcebergQty;
            }

            if (stopLimitTimeInForce !== undefined && stopLimitTimeInForce !== null) {
                localVarQueryParameter['stopLimitTimeInForce'] = stopLimitTimeInForce;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/order/oco',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Test new order creation and signature/recvWindow long.
         * Creates and validates a new order but does not send it into the matching engine.
         * Weight: |Condition| Request Weight|
         * |------------           | ------------ |
         * |Without `computeCommissionRates`| 1|
         * |With `computeCommissionRates`|20|
         *
         * @summary Test new order
         * @param {string} symbol
         * @param {OrderTestSideEnum} side
         * @param {OrderTestTypeEnum} type
         * @param {boolean} [computeCommissionRates] Default: `false`
         * @param {OrderTestTimeInForceEnum} [timeInForce]
         * @param {number} [quantity]
         * @param {number} [quoteOrderQty]
         * @param {number} [price]
         * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
         * @param {number} [strategyId]
         * @param {number} [strategyType] The value cannot be less than `1000000`.
         * @param {number} [stopPrice] Used with `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, and `TAKE_PROFIT_LIMIT` orders.
         * @param {number} [trailingDelta] See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
         * @param {number} [icebergQty] Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
         * @param {OrderTestNewOrderRespTypeEnum} [newOrderRespType]
         * @param {OrderTestSelfTradePreventionModeEnum} [selfTradePreventionMode]
         * @param {number} [recvWindow] The value cannot be greater than `60000`
         *
         * @throws {RequiredError}
         */
        orderTest: async (
            symbol: string,
            side: OrderTestSideEnum,
            type: OrderTestTypeEnum,
            computeCommissionRates?: boolean,
            timeInForce?: OrderTestTimeInForceEnum,
            quantity?: number,
            quoteOrderQty?: number,
            price?: number,
            newClientOrderId?: string,
            strategyId?: number,
            strategyType?: number,
            stopPrice?: number,
            trailingDelta?: number,
            icebergQty?: number,
            newOrderRespType?: OrderTestNewOrderRespTypeEnum,
            selfTradePreventionMode?: OrderTestSelfTradePreventionModeEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('orderTest', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('orderTest', 'side', side);
            // verify required parameter 'type' is not null or undefined
            assertParamExists('orderTest', 'type', type);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (computeCommissionRates !== undefined && computeCommissionRates !== null) {
                localVarQueryParameter['computeCommissionRates'] = computeCommissionRates;
            }

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            if (timeInForce !== undefined && timeInForce !== null) {
                localVarQueryParameter['timeInForce'] = timeInForce;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (quoteOrderQty !== undefined && quoteOrderQty !== null) {
                localVarQueryParameter['quoteOrderQty'] = quoteOrderQty;
            }

            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }

            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (strategyId !== undefined && strategyId !== null) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (strategyType !== undefined && strategyType !== null) {
                localVarQueryParameter['strategyType'] = strategyType;
            }

            if (stopPrice !== undefined && stopPrice !== null) {
                localVarQueryParameter['stopPrice'] = stopPrice;
            }

            if (trailingDelta !== undefined && trailingDelta !== null) {
                localVarQueryParameter['trailingDelta'] = trailingDelta;
            }

            if (icebergQty !== undefined && icebergQty !== null) {
                localVarQueryParameter['icebergQty'] = icebergQty;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/order/test',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Places an order using smart order routing (SOR).
         *
         * This adds 1 order to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
         *
         * Read [SOR FAQ](faqs/sor_faq.md) to learn more.
         * Weight: 1
         *
         * Unfilled Order Count: 1
         *
         * @summary New order using SOR
         * @param {string} symbol
         * @param {SorOrderSideEnum} side
         * @param {SorOrderTypeEnum} type
         * @param {number} quantity
         * @param {SorOrderTimeInForceEnum} [timeInForce]
         * @param {number} [price]
         * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
         * @param {number} [strategyId]
         * @param {number} [strategyType] The value cannot be less than `1000000`.
         * @param {number} [icebergQty] Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
         * @param {SorOrderNewOrderRespTypeEnum} [newOrderRespType]
         * @param {SorOrderSelfTradePreventionModeEnum} [selfTradePreventionMode]
         * @param {number} [recvWindow] The value cannot be greater than `60000`
         *
         * @throws {RequiredError}
         */
        sorOrder: async (
            symbol: string,
            side: SorOrderSideEnum,
            type: SorOrderTypeEnum,
            quantity: number,
            timeInForce?: SorOrderTimeInForceEnum,
            price?: number,
            newClientOrderId?: string,
            strategyId?: number,
            strategyType?: number,
            icebergQty?: number,
            newOrderRespType?: SorOrderNewOrderRespTypeEnum,
            selfTradePreventionMode?: SorOrderSelfTradePreventionModeEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('sorOrder', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('sorOrder', 'side', side);
            // verify required parameter 'type' is not null or undefined
            assertParamExists('sorOrder', 'type', type);
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('sorOrder', 'quantity', quantity);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            if (timeInForce !== undefined && timeInForce !== null) {
                localVarQueryParameter['timeInForce'] = timeInForce;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }

            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (strategyId !== undefined && strategyId !== null) {
                localVarQueryParameter['strategyId'] = strategyId;
            }

            if (strategyType !== undefined && strategyType !== null) {
                localVarQueryParameter['strategyType'] = strategyType;
            }

            if (icebergQty !== undefined && icebergQty !== null) {
                localVarQueryParameter['icebergQty'] = icebergQty;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/sor/order',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Test new order creation and signature/recvWindow using smart order routing (SOR).
         * Creates and validates a new order but does not send it into the matching engine.
         * Weight: | Condition | Request Weight |
         * | --------- | -------------- |
         * | Without `computeCommissionRates`  |  1 |
         * | With `computeCommissionRates`     | 20 |
         *
         * @summary Test new order using SOR
         * @param {boolean} [computeCommissionRates] Default: `false`
         *
         * @throws {RequiredError}
         */
        sorOrderTest: async (computeCommissionRates?: boolean): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (computeCommissionRates !== undefined && computeCommissionRates !== null) {
                localVarQueryParameter['computeCommissionRates'] = computeCommissionRates;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/sor/order/test',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
    };
};

/**
 * TradeApi - interface
 * @interface TradeApi
 */
export interface TradeApiInterface {
    /**
     * Cancels all active orders on a symbol.
     * This includes orders that are part of an order list.
     * Weight: 1
     *
     * @summary Cancel All Open Orders on a Symbol
     * @param {DeleteOpenOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    deleteOpenOrders(
        requestParameters: DeleteOpenOrdersRequest
    ): Promise<RestApiResponse<DeleteOpenOrdersResponse>>;
    /**
     * Cancel an active order.
     * Weight: 1
     *
     * @summary Cancel order
     * @param {DeleteOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    deleteOrder(
        requestParameters: DeleteOrderRequest
    ): Promise<RestApiResponse<DeleteOrderResponse>>;
    /**
     * Cancel an entire Order list
     * Weight: 1
     *
     * @summary Cancel Order list
     * @param {DeleteOrderListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    deleteOrderList(
        requestParameters: DeleteOrderListRequest
    ): Promise<RestApiResponse<DeleteOrderListResponse>>;
    /**
     * Send in a new order.
     *
     * This adds 1 order to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * @summary New order
     * @param {NewOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    newOrder(requestParameters: NewOrderRequest): Promise<RestApiResponse<NewOrderResponse>>;
    /**
     * Reduce the quantity of an existing open order.
     *
     * This adds 0 orders to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
     *
     * Read [Order Amend Keep Priority FAQ](faqs/order_amend_keep_priority.md) to learn more.
     * Weight: 4
     *
     * @summary Order Amend Keep Priority
     * @param {OrderAmendKeepPriorityRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    orderAmendKeepPriority(
        requestParameters: OrderAmendKeepPriorityRequest
    ): Promise<RestApiResponse<OrderAmendKeepPriorityResponse>>;
    /**
     * Cancels an existing order and places a new order on the same symbol.
     *
     * Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.
     *
     * A new order that was not attempted (i.e. when `newOrderResult: NOT_ATTEMPTED`), will still increase the unfilled order count by 1.
     * Weight: 1
     *
     * @summary Cancel an Existing Order and Send a New Order
     * @param {OrderCancelReplaceRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    orderCancelReplace(
        requestParameters: OrderCancelReplaceRequest
    ): Promise<RestApiResponse<OrderCancelReplaceResponse>>;
    /**
     * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other.
     *
     * An OCO has 2 orders called the **above order** and **below order**.
     * One of the orders must be a `LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT` order and the other must be `STOP_LOSS` or `STOP_LOSS_LIMIT` order.
     * Price restrictions
     * If the OCO is on the `SELL` side:
     * `LIMIT_MAKER/TAKE_PROFIT_LIMIT` `price` > Last Traded Price >  `STOP_LOSS/STOP_LOSS_LIMIT` `stopPrice`
     * `TAKE_PROFIT stopPrice` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
     * If the OCO is on the `BUY` side:
     * `LIMIT_MAKER/TAKE_PROFIT_LIMIT price` < Last Traded Price < `stopPrice`
     * `TAKE_PROFIT stopPrice` < Last Traded Price < `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
     * OCOs add **2 orders** to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * Unfilled Order Count: 2
     *
     * @summary New Order list - OCO
     * @param {OrderListOcoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    orderListOco(
        requestParameters: OrderListOcoRequest
    ): Promise<RestApiResponse<OrderListOcoResponse>>;
    /**
     * Place an OTO.
     *
     * An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
     * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
     * The second order is called the **pending order**. It can be any order type except for `MARKET` orders using parameter `quoteOrderQty`. The pending order is only placed on the order book when the working order gets **fully filled**.
     * If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
     * When the order list is placed, if the working order gets **immediately fully filled**, the placement response will show the working order as `FILLED` but the pending order will still appear as `PENDING_NEW`. You need to query the status of the pending order again to see its updated status.
     * OTOs add **2 orders** to the `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * Unfilled Order Count: 2
     *
     * @summary New Order list - OTO
     * @param {OrderListOtoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    orderListOto(
        requestParameters: OrderListOtoRequest
    ): Promise<RestApiResponse<OrderListOtoResponse>>;
    /**
     * Place an OTOCO.
     *
     * An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
     * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
     * The behavior of the working order is the same as the [OTO](#new-order-list---oto-trade).
     * OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets **fully filled**.
     * The rules of the pending above and pending below follow the same rules as the [Order list OCO](#new-order-list---oco-trade).
     * OTOCOs add **3 orders** to the `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * Unfilled Order Count: 3
     *
     * @summary New Order list - OTOCO
     * @param {OrderListOtocoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    orderListOtoco(
        requestParameters: OrderListOtocoRequest
    ): Promise<RestApiResponse<OrderListOtocoResponse>>;
    /**
     * Send in a new OCO.
     *
     * Price Restrictions:
     * `SELL`: Limit Price > Last Price > Stop Price
     * `BUY`: Limit Price < Last Price < Stop Price
     * Quantity Restrictions:
     * Both legs must have the same quantity.
     * `ICEBERG` quantities however do not have to be the same
     * `OCO` adds **2 orders** to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * Unfilled Order Count: 2
     *
     * @summary New OCO - Deprecated
     * @param {OrderOcoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    orderOco(requestParameters: OrderOcoRequest): Promise<RestApiResponse<OrderOcoResponse>>;
    /**
     * Test new order creation and signature/recvWindow long.
     * Creates and validates a new order but does not send it into the matching engine.
     * Weight: |Condition| Request Weight|
     * |------------           | ------------ |
     * |Without `computeCommissionRates`| 1|
     * |With `computeCommissionRates`|20|
     *
     * @summary Test new order
     * @param {OrderTestRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    orderTest(requestParameters: OrderTestRequest): Promise<RestApiResponse<OrderTestResponse>>;
    /**
     * Places an order using smart order routing (SOR).
     *
     * This adds 1 order to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
     *
     * Read [SOR FAQ](faqs/sor_faq.md) to learn more.
     * Weight: 1
     *
     * Unfilled Order Count: 1
     *
     * @summary New order using SOR
     * @param {SorOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    sorOrder(requestParameters: SorOrderRequest): Promise<RestApiResponse<SorOrderResponse>>;
    /**
     * Test new order creation and signature/recvWindow using smart order routing (SOR).
     * Creates and validates a new order but does not send it into the matching engine.
     * Weight: | Condition | Request Weight |
     * | --------- | -------------- |
     * | Without `computeCommissionRates`  |  1 |
     * | With `computeCommissionRates`     | 20 |
     *
     * @summary Test new order using SOR
     * @param {SorOrderTestRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    sorOrderTest(
        requestParameters?: SorOrderTestRequest
    ): Promise<RestApiResponse<SorOrderTestResponse>>;
}

/**
 * Request parameters for deleteOpenOrders operation in TradeApi.
 * @interface DeleteOpenOrdersRequest
 */
export interface DeleteOpenOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiDeleteOpenOrders
     */
    readonly symbol: string;

    /**
     * The value cannot be greater than `60000`
     * @type {number}
     * @memberof TradeApiDeleteOpenOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for deleteOrder operation in TradeApi.
 * @interface DeleteOrderRequest
 */
export interface DeleteOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiDeleteOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiDeleteOrder
     */
    readonly orderId?: number;

    /**
     *
     * @type {string}
     * @memberof TradeApiDeleteOrder
     */
    readonly origClientOrderId?: string;

    /**
     * A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
     * @type {string}
     * @memberof TradeApiDeleteOrder
     */
    readonly newClientOrderId?: string;

    /**
     *
     * @type {'ONLY_NEW' | 'NEW' | 'ONLY_PARTIALLY_FILLED' | 'PARTIALLY_FILLED'}
     * @memberof TradeApiDeleteOrder
     */
    readonly cancelRestrictions?: DeleteOrderCancelRestrictionsEnum;

    /**
     * The value cannot be greater than `60000`
     * @type {number}
     * @memberof TradeApiDeleteOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for deleteOrderList operation in TradeApi.
 * @interface DeleteOrderListRequest
 */
export interface DeleteOrderListRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiDeleteOrderList
     */
    readonly symbol: string;

    /**
     * Either `orderListId` or `listClientOrderId` must be provided
     * @type {number}
     * @memberof TradeApiDeleteOrderList
     */
    readonly orderListId?: number;

    /**
     * A unique Id for the entire orderList
     * @type {string}
     * @memberof TradeApiDeleteOrderList
     */
    readonly listClientOrderId?: string;

    /**
     * A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
     * @type {string}
     * @memberof TradeApiDeleteOrderList
     */
    readonly newClientOrderId?: string;

    /**
     * The value cannot be greater than `60000`
     * @type {number}
     * @memberof TradeApiDeleteOrderList
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for newOrder operation in TradeApi.
 * @interface NewOrderRequest
 */
export interface NewOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiNewOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiNewOrder
     */
    readonly side: NewOrderSideEnum;

    /**
     *
     * @type {'MARKET' | 'LIMIT' | 'STOP_LOSS' | 'STOP_LOSS_LIMIT' | 'TAKE_PROFIT' | 'TAKE_PROFIT_LIMIT' | 'LIMIT_MAKER' | 'NON_REPRESENTABLE'}
     * @memberof TradeApiNewOrder
     */
    readonly type: NewOrderTypeEnum;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK' | 'NON_REPRESENTABLE'}
     * @memberof TradeApiNewOrder
     */
    readonly timeInForce?: NewOrderTimeInForceEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly quantity?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly quoteOrderQty?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly price?: number;

    /**
     * A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
     * @type {string}
     * @memberof TradeApiNewOrder
     */
    readonly newClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly strategyId?: number;

    /**
     * The value cannot be less than `1000000`.
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly strategyType?: number;

    /**
     * Used with `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, and `TAKE_PROFIT_LIMIT` orders.
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly stopPrice?: number;

    /**
     * See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly trailingDelta?: number;

    /**
     * Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly icebergQty?: number;

    /**
     *
     * @type {'ACK' | 'RESULT' | 'FULL' | 'MARKET' | 'LIMIT'}
     * @memberof TradeApiNewOrder
     */
    readonly newOrderRespType?: NewOrderNewOrderRespTypeEnum;

    /**
     *
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_MAKER' | 'EXPIRE_BOTH' | 'DECREMENT' | 'NON_REPRESENTABLE'}
     * @memberof TradeApiNewOrder
     */
    readonly selfTradePreventionMode?: NewOrderSelfTradePreventionModeEnum;

    /**
     * The value cannot be greater than `60000`
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for orderAmendKeepPriority operation in TradeApi.
 * @interface OrderAmendKeepPriorityRequest
 */
export interface OrderAmendKeepPriorityRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiOrderAmendKeepPriority
     */
    readonly symbol: string;

    /**
     * `newQty` must be greater than 0 and less than the order's quantity.
     * @type {number}
     * @memberof TradeApiOrderAmendKeepPriority
     */
    readonly newQty: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderAmendKeepPriority
     */
    readonly orderId?: number;

    /**
     *
     * @type {string}
     * @memberof TradeApiOrderAmendKeepPriority
     */
    readonly origClientOrderId?: string;

    /**
     * A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
     * @type {string}
     * @memberof TradeApiOrderAmendKeepPriority
     */
    readonly newClientOrderId?: string;

    /**
     * The value cannot be greater than `60000`
     * @type {number}
     * @memberof TradeApiOrderAmendKeepPriority
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for orderCancelReplace operation in TradeApi.
 * @interface OrderCancelReplaceRequest
 */
export interface OrderCancelReplaceRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly symbol: string;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly side: OrderCancelReplaceSideEnum;

    /**
     *
     * @type {'MARKET' | 'LIMIT' | 'STOP_LOSS' | 'STOP_LOSS_LIMIT' | 'TAKE_PROFIT' | 'TAKE_PROFIT_LIMIT' | 'LIMIT_MAKER' | 'NON_REPRESENTABLE'}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly type: OrderCancelReplaceTypeEnum;

    /**
     *
     * @type {'STOP_ON_FAILURE' | 'ALLOW_FAILURE'}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK' | 'NON_REPRESENTABLE'}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly timeInForce?: OrderCancelReplaceTimeInForceEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly quantity?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly quoteOrderQty?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly price?: number;

    /**
     * Used to uniquely identify this cancel. Automatically generated by default.
     * @type {string}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly cancelNewClientOrderId?: string;

    /**
     * Either `cancelOrderId` or `cancelOrigClientOrderId` must be sent. <br></br> If both `cancelOrderId` and `cancelOrigClientOrderId` parameters are provided, the `cancelOrderId` is searched first, then the `cancelOrigClientOrderId` from that result is checked against that order. <br></br> If both conditions are not met the request will be rejected.
     * @type {string}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly cancelOrigClientOrderId?: string;

    /**
     * Either `cancelOrderId` or `cancelOrigClientOrderId` must be sent. <br></br>If both `cancelOrderId` and `cancelOrigClientOrderId` parameters are provided, the `cancelOrderId` is searched first, then the `cancelOrigClientOrderId` from that result is checked against that order. <br></br>If both conditions are not met the request will be rejected.
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly cancelOrderId?: number;

    /**
     * A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
     * @type {string}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly newClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly strategyId?: number;

    /**
     * The value cannot be less than `1000000`.
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly strategyType?: number;

    /**
     * Used with `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, and `TAKE_PROFIT_LIMIT` orders.
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly stopPrice?: number;

    /**
     * See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly trailingDelta?: number;

    /**
     * Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly icebergQty?: number;

    /**
     *
     * @type {'ACK' | 'RESULT' | 'FULL' | 'MARKET' | 'LIMIT'}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly newOrderRespType?: OrderCancelReplaceNewOrderRespTypeEnum;

    /**
     *
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_MAKER' | 'EXPIRE_BOTH' | 'DECREMENT' | 'NON_REPRESENTABLE'}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly selfTradePreventionMode?: OrderCancelReplaceSelfTradePreventionModeEnum;

    /**
     *
     * @type {'ONLY_NEW' | 'NEW' | 'ONLY_PARTIALLY_FILLED' | 'PARTIALLY_FILLED'}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly cancelRestrictions?: OrderCancelReplaceCancelRestrictionsEnum;

    /**
     *
     * @type {'DO_NOTHING' | 'CANCEL_ONLY'}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly orderRateLimitExceededMode?: OrderCancelReplaceOrderRateLimitExceededModeEnum;

    /**
     * The value cannot be greater than `60000`
     * @type {number}
     * @memberof TradeApiOrderCancelReplace
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for orderListOco operation in TradeApi.
 * @interface OrderListOcoRequest
 */
export interface OrderListOcoRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiOrderListOco
     */
    readonly symbol: string;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiOrderListOco
     */
    readonly side: OrderListOcoSideEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly quantity: number;

    /**
     *
     * @type {'STOP_LOSS_LIMIT' | 'STOP_LOSS' | 'LIMIT_MAKER' | 'TAKE_PROFIT' | 'TAKE_PROFIT_LIMIT'}
     * @memberof TradeApiOrderListOco
     */
    readonly aboveType: OrderListOcoAboveTypeEnum;

    /**
     *
     * @type {'STOP_LOSS' | 'STOP_LOSS_LIMIT' | 'TAKE_PROFIT' | 'TAKE_PROFIT_LIMIT'}
     * @memberof TradeApiOrderListOco
     */
    readonly belowType: OrderListOcoBelowTypeEnum;

    /**
     * A unique Id for the entire orderList
     * @type {string}
     * @memberof TradeApiOrderListOco
     */
    readonly listClientOrderId?: string;

    /**
     * Arbitrary unique ID among open orders for the above order. Automatically generated if not sent
     * @type {string}
     * @memberof TradeApiOrderListOco
     */
    readonly aboveClientOrderId?: string;

    /**
     * Note that this can only be used if `aboveTimeInForce` is `GTC`.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly aboveIcebergQty?: number;

    /**
     * Can be used if `aboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly abovePrice?: number;

    /**
     * Can be used if `aboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT`. <br>Either `aboveStopPrice` or `aboveTrailingDelta` or both, must be specified.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly aboveStopPrice?: number;

    /**
     * See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly aboveTrailingDelta?: number;

    /**
     * Required if `aboveType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT`
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly aboveTimeInForce?: number;

    /**
     * Arbitrary numeric value identifying the above order within an order strategy.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly aboveStrategyId?: number;

    /**
     * Arbitrary numeric value identifying the above order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly aboveStrategyType?: number;

    /**
     * Arbitrary unique ID among open orders for the below order. Automatically generated if not sent
     * @type {string}
     * @memberof TradeApiOrderListOco
     */
    readonly belowClientOrderId?: string;

    /**
     * Note that this can only be used if `belowTimeInForce` is `GTC`.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly belowIcebergQty?: number;

    /**
     * Can be used if `belowType` is `STOP_LOSS_LIMIT`, `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly belowPrice?: number;

    /**
     * Can be used if `belowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT, TAKE_PROFIT` or `TAKE_PROFIT_LIMIT` <br>Either belowStopPrice or belowTrailingDelta or both, must be specified.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly belowStopPrice?: number;

    /**
     * See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly belowTrailingDelta?: number;

    /**
     *
     * @type {'belowType' | 'STOP_LOSS_LIMIT' | 'TAKE_PROFIT_LIMIT'}
     * @memberof TradeApiOrderListOco
     */
    readonly belowTimeInForce?: OrderListOcoBelowTimeInForceEnum;

    /**
     * Arbitrary numeric value identifying the below order within an order strategy.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly belowStrategyId?: number;

    /**
     * Arbitrary numeric value identifying the below order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly belowStrategyType?: number;

    /**
     *
     * @type {'ACK' | 'RESULT' | 'FULL' | 'MARKET' | 'LIMIT'}
     * @memberof TradeApiOrderListOco
     */
    readonly newOrderRespType?: OrderListOcoNewOrderRespTypeEnum;

    /**
     *
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_MAKER' | 'EXPIRE_BOTH' | 'DECREMENT' | 'NON_REPRESENTABLE'}
     * @memberof TradeApiOrderListOco
     */
    readonly selfTradePreventionMode?: OrderListOcoSelfTradePreventionModeEnum;

    /**
     * The value cannot be greater than `60000`
     * @type {number}
     * @memberof TradeApiOrderListOco
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for orderListOto operation in TradeApi.
 * @interface OrderListOtoRequest
 */
export interface OrderListOtoRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiOrderListOto
     */
    readonly symbol: string;

    /**
     *
     * @type {'LIMIT' | 'LIMIT_MAKER'}
     * @memberof TradeApiOrderListOto
     */
    readonly workingType: OrderListOtoWorkingTypeEnum;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiOrderListOto
     */
    readonly workingSide: OrderListOtoWorkingSideEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly workingPrice: number;

    /**
     * Sets the quantity for the working order.
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly workingQuantity: number;

    /**
     *
     * @type {'LIMIT' | 'MARKET' | 'STOP_LOSS' | 'STOP_LOSS_LIMIT' | 'TAKE_PROFIT' | 'TAKE_PROFIT_LIMIT' | 'LIMIT_MAKER'}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingType: OrderListOtoPendingTypeEnum;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingSide: OrderListOtoPendingSideEnum;

    /**
     * Sets the quantity for the pending order.
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingQuantity: number;

    /**
     * A unique Id for the entire orderList
     * @type {string}
     * @memberof TradeApiOrderListOto
     */
    readonly listClientOrderId?: string;

    /**
     *
     * @type {'ACK' | 'RESULT' | 'FULL' | 'MARKET' | 'LIMIT'}
     * @memberof TradeApiOrderListOto
     */
    readonly newOrderRespType?: OrderListOtoNewOrderRespTypeEnum;

    /**
     *
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_MAKER' | 'EXPIRE_BOTH' | 'DECREMENT' | 'NON_REPRESENTABLE'}
     * @memberof TradeApiOrderListOto
     */
    readonly selfTradePreventionMode?: OrderListOtoSelfTradePreventionModeEnum;

    /**
     * Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
     * @type {string}
     * @memberof TradeApiOrderListOto
     */
    readonly workingClientOrderId?: string;

    /**
     * This can only be used if `workingTimeInForce` is `GTC`, or if `workingType` is `LIMIT_MAKER`.
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly workingIcebergQty?: number;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK'}
     * @memberof TradeApiOrderListOto
     */
    readonly workingTimeInForce?: OrderListOtoWorkingTimeInForceEnum;

    /**
     * Arbitrary numeric value identifying the working order within an order strategy.
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly workingStrategyId?: number;

    /**
     * Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly workingStrategyType?: number;

    /**
     * Arbitrary unique ID among open orders for the pending order.<br> Automatically generated if not sent.
     * @type {string}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingPrice?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingStopPrice?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingTrailingDelta?: number;

    /**
     * This can only be used if `pendingTimeInForce` is `GTC` or if `pendingType` is `LIMIT_MAKER`.
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingIcebergQty?: number;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK'}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingTimeInForce?: OrderListOtoPendingTimeInForceEnum;

    /**
     * Arbitrary numeric value identifying the pending order within an order strategy.
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingStrategyId?: number;

    /**
     * Arbitrary numeric value identifying the pending order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly pendingStrategyType?: number;

    /**
     * The value cannot be greater than `60000`
     * @type {number}
     * @memberof TradeApiOrderListOto
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for orderListOtoco operation in TradeApi.
 * @interface OrderListOtocoRequest
 */
export interface OrderListOtocoRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiOrderListOtoco
     */
    readonly symbol: string;

    /**
     *
     * @type {'LIMIT' | 'LIMIT_MAKER'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly workingType: OrderListOtocoWorkingTypeEnum;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly workingSide: OrderListOtocoWorkingSideEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly workingPrice: number;

    /**
     * Sets the quantity for the working order.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly workingQuantity: number;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingSide: OrderListOtocoPendingSideEnum;

    /**
     * Sets the quantity for the pending order.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingQuantity: number;

    /**
     *
     * @type {'STOP_LOSS_LIMIT' | 'STOP_LOSS' | 'LIMIT_MAKER' | 'TAKE_PROFIT' | 'TAKE_PROFIT_LIMIT'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingAboveType: OrderListOtocoPendingAboveTypeEnum;

    /**
     * A unique Id for the entire orderList
     * @type {string}
     * @memberof TradeApiOrderListOtoco
     */
    readonly listClientOrderId?: string;

    /**
     *
     * @type {'ACK' | 'RESULT' | 'FULL' | 'MARKET' | 'LIMIT'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly newOrderRespType?: OrderListOtocoNewOrderRespTypeEnum;

    /**
     *
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_MAKER' | 'EXPIRE_BOTH' | 'DECREMENT' | 'NON_REPRESENTABLE'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly selfTradePreventionMode?: OrderListOtocoSelfTradePreventionModeEnum;

    /**
     * Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
     * @type {string}
     * @memberof TradeApiOrderListOtoco
     */
    readonly workingClientOrderId?: string;

    /**
     * This can only be used if `workingTimeInForce` is `GTC`, or if `workingType` is `LIMIT_MAKER`.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly workingIcebergQty?: number;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly workingTimeInForce?: OrderListOtocoWorkingTimeInForceEnum;

    /**
     * Arbitrary numeric value identifying the working order within an order strategy.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly workingStrategyId?: number;

    /**
     * Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly workingStrategyType?: number;

    /**
     * Arbitrary unique ID among open orders for the pending above order.<br> Automatically generated if not sent.
     * @type {string}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingAboveClientOrderId?: string;

    /**
     * Can be used if `pendingAboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingAbovePrice?: number;

    /**
     * Can be used if `pendingAboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT`
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingAboveStopPrice?: number;

    /**
     * See [Trailing Stop FAQ](faqs/trailing-stop-faq.md)
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingAboveTrailingDelta?: number;

    /**
     * This can only be used if `pendingAboveTimeInForce` is `GTC` or if `pendingAboveType` is `LIMIT_MAKER`.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingAboveIcebergQty?: number;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingAboveTimeInForce?: OrderListOtocoPendingAboveTimeInForceEnum;

    /**
     * Arbitrary numeric value identifying the pending above order within an order strategy.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingAboveStrategyId?: number;

    /**
     * Arbitrary numeric value identifying the pending above order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingAboveStrategyType?: number;

    /**
     *
     * @type {'STOP_LOSS' | 'STOP_LOSS_LIMIT' | 'TAKE_PROFIT' | 'TAKE_PROFIT_LIMIT'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingBelowType?: OrderListOtocoPendingBelowTypeEnum;

    /**
     * Arbitrary unique ID among open orders for the pending below order.<br> Automatically generated if not sent.
     * @type {string}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingBelowClientOrderId?: string;

    /**
     * Can be used if `pendingBelowType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT` to specify limit price
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingBelowPrice?: number;

    /**
     * Can be used if `pendingBelowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT, TAKE_PROFIT or TAKE_PROFIT_LIMIT`. <br>Either `pendingBelowStopPrice` or `pendingBelowTrailingDelta` or both, must be specified.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingBelowStopPrice?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingBelowTrailingDelta?: number;

    /**
     * This can only be used if `pendingBelowTimeInForce` is `GTC`, or if `pendingBelowType` is `LIMIT_MAKER`.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingBelowIcebergQty?: number;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK'}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingBelowTimeInForce?: OrderListOtocoPendingBelowTimeInForceEnum;

    /**
     * Arbitrary numeric value identifying the pending below order within an order strategy.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingBelowStrategyId?: number;

    /**
     * Arbitrary numeric value identifying the pending below order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly pendingBelowStrategyType?: number;

    /**
     * The value cannot be greater than `60000`
     * @type {number}
     * @memberof TradeApiOrderListOtoco
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for orderOco operation in TradeApi.
 * @interface OrderOcoRequest
 */
export interface OrderOcoRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiOrderOco
     */
    readonly symbol: string;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiOrderOco
     */
    readonly side: OrderOcoSideEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly quantity: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly price: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly stopPrice: number;

    /**
     * A unique Id for the entire orderList
     * @type {string}
     * @memberof TradeApiOrderOco
     */
    readonly listClientOrderId?: string;

    /**
     * A unique Id for the limit order
     * @type {string}
     * @memberof TradeApiOrderOco
     */
    readonly limitClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly limitStrategyId?: number;

    /**
     * The value cannot be less than `1000000`.
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly limitStrategyType?: number;

    /**
     * Used to make the `LIMIT_MAKER` leg an iceberg order.
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly limitIcebergQty?: number;

    /**
     * See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly trailingDelta?: number;

    /**
     * A unique Id for the stop loss/stop loss limit leg
     * @type {string}
     * @memberof TradeApiOrderOco
     */
    readonly stopClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly stopStrategyId?: number;

    /**
     * The value cannot be less than `1000000`.
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly stopStrategyType?: number;

    /**
     * If provided, `stopLimitTimeInForce` is required.
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly stopLimitPrice?: number;

    /**
     * Used with `STOP_LOSS_LIMIT` leg to make an iceberg order.
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly stopIcebergQty?: number;

    /**
     *
     * @type {'GTC' | 'FOK' | 'IOC'}
     * @memberof TradeApiOrderOco
     */
    readonly stopLimitTimeInForce?: OrderOcoStopLimitTimeInForceEnum;

    /**
     *
     * @type {'ACK' | 'RESULT' | 'FULL' | 'MARKET' | 'LIMIT'}
     * @memberof TradeApiOrderOco
     */
    readonly newOrderRespType?: OrderOcoNewOrderRespTypeEnum;

    /**
     *
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_MAKER' | 'EXPIRE_BOTH' | 'DECREMENT' | 'NON_REPRESENTABLE'}
     * @memberof TradeApiOrderOco
     */
    readonly selfTradePreventionMode?: OrderOcoSelfTradePreventionModeEnum;

    /**
     * The value cannot be greater than `60000`
     * @type {number}
     * @memberof TradeApiOrderOco
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for orderTest operation in TradeApi.
 * @interface OrderTestRequest
 */
export interface OrderTestRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiOrderTest
     */
    readonly symbol: string;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiOrderTest
     */
    readonly side: OrderTestSideEnum;

    /**
     *
     * @type {'MARKET' | 'LIMIT' | 'STOP_LOSS' | 'STOP_LOSS_LIMIT' | 'TAKE_PROFIT' | 'TAKE_PROFIT_LIMIT' | 'LIMIT_MAKER' | 'NON_REPRESENTABLE'}
     * @memberof TradeApiOrderTest
     */
    readonly type: OrderTestTypeEnum;

    /**
     * Default: `false`
     * @type {boolean}
     * @memberof TradeApiOrderTest
     */
    readonly computeCommissionRates?: boolean;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK' | 'NON_REPRESENTABLE'}
     * @memberof TradeApiOrderTest
     */
    readonly timeInForce?: OrderTestTimeInForceEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderTest
     */
    readonly quantity?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderTest
     */
    readonly quoteOrderQty?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderTest
     */
    readonly price?: number;

    /**
     * A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
     * @type {string}
     * @memberof TradeApiOrderTest
     */
    readonly newClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiOrderTest
     */
    readonly strategyId?: number;

    /**
     * The value cannot be less than `1000000`.
     * @type {number}
     * @memberof TradeApiOrderTest
     */
    readonly strategyType?: number;

    /**
     * Used with `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, and `TAKE_PROFIT_LIMIT` orders.
     * @type {number}
     * @memberof TradeApiOrderTest
     */
    readonly stopPrice?: number;

    /**
     * See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
     * @type {number}
     * @memberof TradeApiOrderTest
     */
    readonly trailingDelta?: number;

    /**
     * Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
     * @type {number}
     * @memberof TradeApiOrderTest
     */
    readonly icebergQty?: number;

    /**
     *
     * @type {'ACK' | 'RESULT' | 'FULL' | 'MARKET' | 'LIMIT'}
     * @memberof TradeApiOrderTest
     */
    readonly newOrderRespType?: OrderTestNewOrderRespTypeEnum;

    /**
     *
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_MAKER' | 'EXPIRE_BOTH' | 'DECREMENT' | 'NON_REPRESENTABLE'}
     * @memberof TradeApiOrderTest
     */
    readonly selfTradePreventionMode?: OrderTestSelfTradePreventionModeEnum;

    /**
     * The value cannot be greater than `60000`
     * @type {number}
     * @memberof TradeApiOrderTest
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for sorOrder operation in TradeApi.
 * @interface SorOrderRequest
 */
export interface SorOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiSorOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiSorOrder
     */
    readonly side: SorOrderSideEnum;

    /**
     *
     * @type {'MARKET' | 'LIMIT' | 'STOP_LOSS' | 'STOP_LOSS_LIMIT' | 'TAKE_PROFIT' | 'TAKE_PROFIT_LIMIT' | 'LIMIT_MAKER' | 'NON_REPRESENTABLE'}
     * @memberof TradeApiSorOrder
     */
    readonly type: SorOrderTypeEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiSorOrder
     */
    readonly quantity: number;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK' | 'NON_REPRESENTABLE'}
     * @memberof TradeApiSorOrder
     */
    readonly timeInForce?: SorOrderTimeInForceEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiSorOrder
     */
    readonly price?: number;

    /**
     * A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
     * @type {string}
     * @memberof TradeApiSorOrder
     */
    readonly newClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiSorOrder
     */
    readonly strategyId?: number;

    /**
     * The value cannot be less than `1000000`.
     * @type {number}
     * @memberof TradeApiSorOrder
     */
    readonly strategyType?: number;

    /**
     * Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
     * @type {number}
     * @memberof TradeApiSorOrder
     */
    readonly icebergQty?: number;

    /**
     *
     * @type {'ACK' | 'RESULT' | 'FULL' | 'MARKET' | 'LIMIT'}
     * @memberof TradeApiSorOrder
     */
    readonly newOrderRespType?: SorOrderNewOrderRespTypeEnum;

    /**
     *
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_MAKER' | 'EXPIRE_BOTH' | 'DECREMENT' | 'NON_REPRESENTABLE'}
     * @memberof TradeApiSorOrder
     */
    readonly selfTradePreventionMode?: SorOrderSelfTradePreventionModeEnum;

    /**
     * The value cannot be greater than `60000`
     * @type {number}
     * @memberof TradeApiSorOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for sorOrderTest operation in TradeApi.
 * @interface SorOrderTestRequest
 */
export interface SorOrderTestRequest {
    /**
     * Default: `false`
     * @type {boolean}
     * @memberof TradeApiSorOrderTest
     */
    readonly computeCommissionRates?: boolean;
}

/**
 * TradeApi - object-oriented interface
 * @class TradeApi
 */
export class TradeApi implements TradeApiInterface {
    private readonly configuration: ConfigurationRestAPI;
    private localVarAxiosParamCreator;

    constructor(configuration: ConfigurationRestAPI) {
        this.configuration = configuration;
        this.localVarAxiosParamCreator = TradeApiAxiosParamCreator(configuration);
    }

    /**
     * Cancels all active orders on a symbol.
     * This includes orders that are part of an order list.
     * Weight: 1
     *
     * @summary Cancel All Open Orders on a Symbol
     * @param {DeleteOpenOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<DeleteOpenOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-all-open-orders-on-a-symbol-trade Binance API Documentation}
     */
    public async deleteOpenOrders(
        requestParameters: DeleteOpenOrdersRequest
    ): Promise<RestApiResponse<DeleteOpenOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.deleteOpenOrders(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<DeleteOpenOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel an active order.
     * Weight: 1
     *
     * @summary Cancel order
     * @param {DeleteOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<DeleteOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-order-trade Binance API Documentation}
     */
    public async deleteOrder(
        requestParameters: DeleteOrderRequest
    ): Promise<RestApiResponse<DeleteOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.deleteOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.newClientOrderId,
            requestParameters?.cancelRestrictions,
            requestParameters?.recvWindow
        );
        return sendRequest<DeleteOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel an entire Order list
     * Weight: 1
     *
     * @summary Cancel Order list
     * @param {DeleteOrderListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<DeleteOrderListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-order-list-trade Binance API Documentation}
     */
    public async deleteOrderList(
        requestParameters: DeleteOrderListRequest
    ): Promise<RestApiResponse<DeleteOrderListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.deleteOrderList(
            requestParameters?.symbol,
            requestParameters?.orderListId,
            requestParameters?.listClientOrderId,
            requestParameters?.newClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<DeleteOrderListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Send in a new order.
     *
     * This adds 1 order to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * @summary New order
     * @param {NewOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<NewOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-trade Binance API Documentation}
     */
    public async newOrder(
        requestParameters: NewOrderRequest
    ): Promise<RestApiResponse<NewOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.newOrder(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.type,
            requestParameters?.timeInForce,
            requestParameters?.quantity,
            requestParameters?.quoteOrderQty,
            requestParameters?.price,
            requestParameters?.newClientOrderId,
            requestParameters?.strategyId,
            requestParameters?.strategyType,
            requestParameters?.stopPrice,
            requestParameters?.trailingDelta,
            requestParameters?.icebergQty,
            requestParameters?.newOrderRespType,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.recvWindow
        );
        return sendRequest<NewOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Reduce the quantity of an existing open order.
     *
     * This adds 0 orders to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
     *
     * Read [Order Amend Keep Priority FAQ](faqs/order_amend_keep_priority.md) to learn more.
     * Weight: 4
     *
     * @summary Order Amend Keep Priority
     * @param {OrderAmendKeepPriorityRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OrderAmendKeepPriorityResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#order-amend-keep-priority-trade Binance API Documentation}
     */
    public async orderAmendKeepPriority(
        requestParameters: OrderAmendKeepPriorityRequest
    ): Promise<RestApiResponse<OrderAmendKeepPriorityResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderAmendKeepPriority(
            requestParameters?.symbol,
            requestParameters?.newQty,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.newClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<OrderAmendKeepPriorityResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancels an existing order and places a new order on the same symbol.
     *
     * Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.
     *
     * A new order that was not attempted (i.e. when `newOrderResult: NOT_ATTEMPTED`), will still increase the unfilled order count by 1.
     * Weight: 1
     *
     * @summary Cancel an Existing Order and Send a New Order
     * @param {OrderCancelReplaceRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OrderCancelReplaceResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-an-existing-order-and-send-a-new-order-trade Binance API Documentation}
     */
    public async orderCancelReplace(
        requestParameters: OrderCancelReplaceRequest
    ): Promise<RestApiResponse<OrderCancelReplaceResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderCancelReplace(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.type,
            requestParameters?.cancelReplaceMode,
            requestParameters?.timeInForce,
            requestParameters?.quantity,
            requestParameters?.quoteOrderQty,
            requestParameters?.price,
            requestParameters?.cancelNewClientOrderId,
            requestParameters?.cancelOrigClientOrderId,
            requestParameters?.cancelOrderId,
            requestParameters?.newClientOrderId,
            requestParameters?.strategyId,
            requestParameters?.strategyType,
            requestParameters?.stopPrice,
            requestParameters?.trailingDelta,
            requestParameters?.icebergQty,
            requestParameters?.newOrderRespType,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.cancelRestrictions,
            requestParameters?.orderRateLimitExceededMode,
            requestParameters?.recvWindow
        );
        return sendRequest<OrderCancelReplaceResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other.
     *
     * An OCO has 2 orders called the **above order** and **below order**.
     * One of the orders must be a `LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT` order and the other must be `STOP_LOSS` or `STOP_LOSS_LIMIT` order.
     * Price restrictions
     * If the OCO is on the `SELL` side:
     * `LIMIT_MAKER/TAKE_PROFIT_LIMIT` `price` > Last Traded Price >  `STOP_LOSS/STOP_LOSS_LIMIT` `stopPrice`
     * `TAKE_PROFIT stopPrice` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
     * If the OCO is on the `BUY` side:
     * `LIMIT_MAKER/TAKE_PROFIT_LIMIT price` < Last Traded Price < `stopPrice`
     * `TAKE_PROFIT stopPrice` < Last Traded Price < `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
     * OCOs add **2 orders** to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * Unfilled Order Count: 2
     *
     * @summary New Order list - OCO
     * @param {OrderListOcoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OrderListOcoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---oco-trade Binance API Documentation}
     */
    public async orderListOco(
        requestParameters: OrderListOcoRequest
    ): Promise<RestApiResponse<OrderListOcoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderListOco(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.quantity,
            requestParameters?.aboveType,
            requestParameters?.belowType,
            requestParameters?.listClientOrderId,
            requestParameters?.aboveClientOrderId,
            requestParameters?.aboveIcebergQty,
            requestParameters?.abovePrice,
            requestParameters?.aboveStopPrice,
            requestParameters?.aboveTrailingDelta,
            requestParameters?.aboveTimeInForce,
            requestParameters?.aboveStrategyId,
            requestParameters?.aboveStrategyType,
            requestParameters?.belowClientOrderId,
            requestParameters?.belowIcebergQty,
            requestParameters?.belowPrice,
            requestParameters?.belowStopPrice,
            requestParameters?.belowTrailingDelta,
            requestParameters?.belowTimeInForce,
            requestParameters?.belowStrategyId,
            requestParameters?.belowStrategyType,
            requestParameters?.newOrderRespType,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.recvWindow
        );
        return sendRequest<OrderListOcoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Place an OTO.
     *
     * An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
     * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
     * The second order is called the **pending order**. It can be any order type except for `MARKET` orders using parameter `quoteOrderQty`. The pending order is only placed on the order book when the working order gets **fully filled**.
     * If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
     * When the order list is placed, if the working order gets **immediately fully filled**, the placement response will show the working order as `FILLED` but the pending order will still appear as `PENDING_NEW`. You need to query the status of the pending order again to see its updated status.
     * OTOs add **2 orders** to the `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * Unfilled Order Count: 2
     *
     * @summary New Order list - OTO
     * @param {OrderListOtoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OrderListOtoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---oto-trade Binance API Documentation}
     */
    public async orderListOto(
        requestParameters: OrderListOtoRequest
    ): Promise<RestApiResponse<OrderListOtoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderListOto(
            requestParameters?.symbol,
            requestParameters?.workingType,
            requestParameters?.workingSide,
            requestParameters?.workingPrice,
            requestParameters?.workingQuantity,
            requestParameters?.pendingType,
            requestParameters?.pendingSide,
            requestParameters?.pendingQuantity,
            requestParameters?.listClientOrderId,
            requestParameters?.newOrderRespType,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.workingClientOrderId,
            requestParameters?.workingIcebergQty,
            requestParameters?.workingTimeInForce,
            requestParameters?.workingStrategyId,
            requestParameters?.workingStrategyType,
            requestParameters?.pendingClientOrderId,
            requestParameters?.pendingPrice,
            requestParameters?.pendingStopPrice,
            requestParameters?.pendingTrailingDelta,
            requestParameters?.pendingIcebergQty,
            requestParameters?.pendingTimeInForce,
            requestParameters?.pendingStrategyId,
            requestParameters?.pendingStrategyType,
            requestParameters?.recvWindow
        );
        return sendRequest<OrderListOtoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Place an OTOCO.
     *
     * An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
     * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
     * The behavior of the working order is the same as the [OTO](#new-order-list---oto-trade).
     * OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets **fully filled**.
     * The rules of the pending above and pending below follow the same rules as the [Order list OCO](#new-order-list---oco-trade).
     * OTOCOs add **3 orders** to the `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * Unfilled Order Count: 3
     *
     * @summary New Order list - OTOCO
     * @param {OrderListOtocoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OrderListOtocoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---otoco-trade Binance API Documentation}
     */
    public async orderListOtoco(
        requestParameters: OrderListOtocoRequest
    ): Promise<RestApiResponse<OrderListOtocoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderListOtoco(
            requestParameters?.symbol,
            requestParameters?.workingType,
            requestParameters?.workingSide,
            requestParameters?.workingPrice,
            requestParameters?.workingQuantity,
            requestParameters?.pendingSide,
            requestParameters?.pendingQuantity,
            requestParameters?.pendingAboveType,
            requestParameters?.listClientOrderId,
            requestParameters?.newOrderRespType,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.workingClientOrderId,
            requestParameters?.workingIcebergQty,
            requestParameters?.workingTimeInForce,
            requestParameters?.workingStrategyId,
            requestParameters?.workingStrategyType,
            requestParameters?.pendingAboveClientOrderId,
            requestParameters?.pendingAbovePrice,
            requestParameters?.pendingAboveStopPrice,
            requestParameters?.pendingAboveTrailingDelta,
            requestParameters?.pendingAboveIcebergQty,
            requestParameters?.pendingAboveTimeInForce,
            requestParameters?.pendingAboveStrategyId,
            requestParameters?.pendingAboveStrategyType,
            requestParameters?.pendingBelowType,
            requestParameters?.pendingBelowClientOrderId,
            requestParameters?.pendingBelowPrice,
            requestParameters?.pendingBelowStopPrice,
            requestParameters?.pendingBelowTrailingDelta,
            requestParameters?.pendingBelowIcebergQty,
            requestParameters?.pendingBelowTimeInForce,
            requestParameters?.pendingBelowStrategyId,
            requestParameters?.pendingBelowStrategyType,
            requestParameters?.recvWindow
        );
        return sendRequest<OrderListOtocoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Send in a new OCO.
     *
     * Price Restrictions:
     * `SELL`: Limit Price > Last Price > Stop Price
     * `BUY`: Limit Price < Last Price < Stop Price
     * Quantity Restrictions:
     * Both legs must have the same quantity.
     * `ICEBERG` quantities however do not have to be the same
     * `OCO` adds **2 orders** to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * Unfilled Order Count: 2
     *
     * @summary New OCO - Deprecated
     * @param {OrderOcoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OrderOcoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-oco---deprecated-trade Binance API Documentation}
     */
    public async orderOco(
        requestParameters: OrderOcoRequest
    ): Promise<RestApiResponse<OrderOcoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderOco(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.quantity,
            requestParameters?.price,
            requestParameters?.stopPrice,
            requestParameters?.listClientOrderId,
            requestParameters?.limitClientOrderId,
            requestParameters?.limitStrategyId,
            requestParameters?.limitStrategyType,
            requestParameters?.limitIcebergQty,
            requestParameters?.trailingDelta,
            requestParameters?.stopClientOrderId,
            requestParameters?.stopStrategyId,
            requestParameters?.stopStrategyType,
            requestParameters?.stopLimitPrice,
            requestParameters?.stopIcebergQty,
            requestParameters?.stopLimitTimeInForce,
            requestParameters?.newOrderRespType,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.recvWindow
        );
        return sendRequest<OrderOcoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Test new order creation and signature/recvWindow long.
     * Creates and validates a new order but does not send it into the matching engine.
     * Weight: |Condition| Request Weight|
     * |------------           | ------------ |
     * |Without `computeCommissionRates`| 1|
     * |With `computeCommissionRates`|20|
     *
     * @summary Test new order
     * @param {OrderTestRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OrderTestResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#test-new-order-trade Binance API Documentation}
     */
    public async orderTest(
        requestParameters: OrderTestRequest
    ): Promise<RestApiResponse<OrderTestResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderTest(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.type,
            requestParameters?.computeCommissionRates,
            requestParameters?.timeInForce,
            requestParameters?.quantity,
            requestParameters?.quoteOrderQty,
            requestParameters?.price,
            requestParameters?.newClientOrderId,
            requestParameters?.strategyId,
            requestParameters?.strategyType,
            requestParameters?.stopPrice,
            requestParameters?.trailingDelta,
            requestParameters?.icebergQty,
            requestParameters?.newOrderRespType,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.recvWindow
        );
        return sendRequest<OrderTestResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Places an order using smart order routing (SOR).
     *
     * This adds 1 order to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
     *
     * Read [SOR FAQ](faqs/sor_faq.md) to learn more.
     * Weight: 1
     *
     * Unfilled Order Count: 1
     *
     * @summary New order using SOR
     * @param {SorOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<SorOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-using-sor-trade Binance API Documentation}
     */
    public async sorOrder(
        requestParameters: SorOrderRequest
    ): Promise<RestApiResponse<SorOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.sorOrder(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.type,
            requestParameters?.quantity,
            requestParameters?.timeInForce,
            requestParameters?.price,
            requestParameters?.newClientOrderId,
            requestParameters?.strategyId,
            requestParameters?.strategyType,
            requestParameters?.icebergQty,
            requestParameters?.newOrderRespType,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.recvWindow
        );
        return sendRequest<SorOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Test new order creation and signature/recvWindow using smart order routing (SOR).
     * Creates and validates a new order but does not send it into the matching engine.
     * Weight: | Condition | Request Weight |
     * | --------- | -------------- |
     * | Without `computeCommissionRates`  |  1 |
     * | With `computeCommissionRates`     | 20 |
     *
     * @summary Test new order using SOR
     * @param {SorOrderTestRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<SorOrderTestResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#test-new-order-using-sor-trade Binance API Documentation}
     */
    public async sorOrderTest(
        requestParameters: SorOrderTestRequest = {}
    ): Promise<RestApiResponse<SorOrderTestResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.sorOrderTest(
            requestParameters?.computeCommissionRates
        );
        return sendRequest<SorOrderTestResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }
}

export enum DeleteOrderCancelRestrictionsEnum {
    ONLY_NEW = 'ONLY_NEW',
    NEW = 'NEW',
    ONLY_PARTIALLY_FILLED = 'ONLY_PARTIALLY_FILLED',
    PARTIALLY_FILLED = 'PARTIALLY_FILLED',
}

export enum NewOrderSideEnum {
    BUY = 'BUY',
    SELL = 'SELL',
}

export enum NewOrderTypeEnum {
    MARKET = 'MARKET',
    LIMIT = 'LIMIT',
    STOP_LOSS = 'STOP_LOSS',
    STOP_LOSS_LIMIT = 'STOP_LOSS_LIMIT',
    TAKE_PROFIT = 'TAKE_PROFIT',
    TAKE_PROFIT_LIMIT = 'TAKE_PROFIT_LIMIT',
    LIMIT_MAKER = 'LIMIT_MAKER',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum NewOrderTimeInForceEnum {
    GTC = 'GTC',
    IOC = 'IOC',
    FOK = 'FOK',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum NewOrderNewOrderRespTypeEnum {
    ACK = 'ACK',
    RESULT = 'RESULT',
    FULL = 'FULL',
    MARKET = 'MARKET',
    LIMIT = 'LIMIT',
}

export enum NewOrderSelfTradePreventionModeEnum {
    NONE = 'NONE',
    EXPIRE_TAKER = 'EXPIRE_TAKER',
    EXPIRE_MAKER = 'EXPIRE_MAKER',
    EXPIRE_BOTH = 'EXPIRE_BOTH',
    DECREMENT = 'DECREMENT',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum OrderCancelReplaceSideEnum {
    BUY = 'BUY',
    SELL = 'SELL',
}

export enum OrderCancelReplaceTypeEnum {
    MARKET = 'MARKET',
    LIMIT = 'LIMIT',
    STOP_LOSS = 'STOP_LOSS',
    STOP_LOSS_LIMIT = 'STOP_LOSS_LIMIT',
    TAKE_PROFIT = 'TAKE_PROFIT',
    TAKE_PROFIT_LIMIT = 'TAKE_PROFIT_LIMIT',
    LIMIT_MAKER = 'LIMIT_MAKER',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum OrderCancelReplaceCancelReplaceModeEnum {
    STOP_ON_FAILURE = 'STOP_ON_FAILURE',
    ALLOW_FAILURE = 'ALLOW_FAILURE',
}

export enum OrderCancelReplaceTimeInForceEnum {
    GTC = 'GTC',
    IOC = 'IOC',
    FOK = 'FOK',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum OrderCancelReplaceNewOrderRespTypeEnum {
    ACK = 'ACK',
    RESULT = 'RESULT',
    FULL = 'FULL',
    MARKET = 'MARKET',
    LIMIT = 'LIMIT',
}

export enum OrderCancelReplaceSelfTradePreventionModeEnum {
    NONE = 'NONE',
    EXPIRE_TAKER = 'EXPIRE_TAKER',
    EXPIRE_MAKER = 'EXPIRE_MAKER',
    EXPIRE_BOTH = 'EXPIRE_BOTH',
    DECREMENT = 'DECREMENT',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum OrderCancelReplaceCancelRestrictionsEnum {
    ONLY_NEW = 'ONLY_NEW',
    NEW = 'NEW',
    ONLY_PARTIALLY_FILLED = 'ONLY_PARTIALLY_FILLED',
    PARTIALLY_FILLED = 'PARTIALLY_FILLED',
}

export enum OrderCancelReplaceOrderRateLimitExceededModeEnum {
    DO_NOTHING = 'DO_NOTHING',
    CANCEL_ONLY = 'CANCEL_ONLY',
}

export enum OrderListOcoSideEnum {
    BUY = 'BUY',
    SELL = 'SELL',
}

export enum OrderListOcoAboveTypeEnum {
    STOP_LOSS_LIMIT = 'STOP_LOSS_LIMIT',
    STOP_LOSS = 'STOP_LOSS',
    LIMIT_MAKER = 'LIMIT_MAKER',
    TAKE_PROFIT = 'TAKE_PROFIT',
    TAKE_PROFIT_LIMIT = 'TAKE_PROFIT_LIMIT',
}

export enum OrderListOcoBelowTypeEnum {
    STOP_LOSS = 'STOP_LOSS',
    STOP_LOSS_LIMIT = 'STOP_LOSS_LIMIT',
    TAKE_PROFIT = 'TAKE_PROFIT',
    TAKE_PROFIT_LIMIT = 'TAKE_PROFIT_LIMIT',
}

export enum OrderListOcoBelowTimeInForceEnum {
    belowType = 'belowType',
    STOP_LOSS_LIMIT = 'STOP_LOSS_LIMIT',
    TAKE_PROFIT_LIMIT = 'TAKE_PROFIT_LIMIT',
}

export enum OrderListOcoNewOrderRespTypeEnum {
    ACK = 'ACK',
    RESULT = 'RESULT',
    FULL = 'FULL',
    MARKET = 'MARKET',
    LIMIT = 'LIMIT',
}

export enum OrderListOcoSelfTradePreventionModeEnum {
    NONE = 'NONE',
    EXPIRE_TAKER = 'EXPIRE_TAKER',
    EXPIRE_MAKER = 'EXPIRE_MAKER',
    EXPIRE_BOTH = 'EXPIRE_BOTH',
    DECREMENT = 'DECREMENT',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum OrderListOtoWorkingTypeEnum {
    LIMIT = 'LIMIT',
    LIMIT_MAKER = 'LIMIT_MAKER',
}

export enum OrderListOtoWorkingSideEnum {
    BUY = 'BUY',
    SELL = 'SELL',
}

export enum OrderListOtoPendingTypeEnum {
    LIMIT = 'LIMIT',
    MARKET = 'MARKET',
    STOP_LOSS = 'STOP_LOSS',
    STOP_LOSS_LIMIT = 'STOP_LOSS_LIMIT',
    TAKE_PROFIT = 'TAKE_PROFIT',
    TAKE_PROFIT_LIMIT = 'TAKE_PROFIT_LIMIT',
    LIMIT_MAKER = 'LIMIT_MAKER',
}

export enum OrderListOtoPendingSideEnum {
    BUY = 'BUY',
    SELL = 'SELL',
}

export enum OrderListOtoNewOrderRespTypeEnum {
    ACK = 'ACK',
    RESULT = 'RESULT',
    FULL = 'FULL',
    MARKET = 'MARKET',
    LIMIT = 'LIMIT',
}

export enum OrderListOtoSelfTradePreventionModeEnum {
    NONE = 'NONE',
    EXPIRE_TAKER = 'EXPIRE_TAKER',
    EXPIRE_MAKER = 'EXPIRE_MAKER',
    EXPIRE_BOTH = 'EXPIRE_BOTH',
    DECREMENT = 'DECREMENT',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum OrderListOtoWorkingTimeInForceEnum {
    GTC = 'GTC',
    IOC = 'IOC',
    FOK = 'FOK',
}

export enum OrderListOtoPendingTimeInForceEnum {
    GTC = 'GTC',
    IOC = 'IOC',
    FOK = 'FOK',
}

export enum OrderListOtocoWorkingTypeEnum {
    LIMIT = 'LIMIT',
    LIMIT_MAKER = 'LIMIT_MAKER',
}

export enum OrderListOtocoWorkingSideEnum {
    BUY = 'BUY',
    SELL = 'SELL',
}

export enum OrderListOtocoPendingSideEnum {
    BUY = 'BUY',
    SELL = 'SELL',
}

export enum OrderListOtocoPendingAboveTypeEnum {
    STOP_LOSS_LIMIT = 'STOP_LOSS_LIMIT',
    STOP_LOSS = 'STOP_LOSS',
    LIMIT_MAKER = 'LIMIT_MAKER',
    TAKE_PROFIT = 'TAKE_PROFIT',
    TAKE_PROFIT_LIMIT = 'TAKE_PROFIT_LIMIT',
}

export enum OrderListOtocoNewOrderRespTypeEnum {
    ACK = 'ACK',
    RESULT = 'RESULT',
    FULL = 'FULL',
    MARKET = 'MARKET',
    LIMIT = 'LIMIT',
}

export enum OrderListOtocoSelfTradePreventionModeEnum {
    NONE = 'NONE',
    EXPIRE_TAKER = 'EXPIRE_TAKER',
    EXPIRE_MAKER = 'EXPIRE_MAKER',
    EXPIRE_BOTH = 'EXPIRE_BOTH',
    DECREMENT = 'DECREMENT',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum OrderListOtocoWorkingTimeInForceEnum {
    GTC = 'GTC',
    IOC = 'IOC',
    FOK = 'FOK',
}

export enum OrderListOtocoPendingAboveTimeInForceEnum {
    GTC = 'GTC',
    IOC = 'IOC',
    FOK = 'FOK',
}

export enum OrderListOtocoPendingBelowTypeEnum {
    STOP_LOSS = 'STOP_LOSS',
    STOP_LOSS_LIMIT = 'STOP_LOSS_LIMIT',
    TAKE_PROFIT = 'TAKE_PROFIT',
    TAKE_PROFIT_LIMIT = 'TAKE_PROFIT_LIMIT',
}

export enum OrderListOtocoPendingBelowTimeInForceEnum {
    GTC = 'GTC',
    IOC = 'IOC',
    FOK = 'FOK',
}

export enum OrderOcoSideEnum {
    BUY = 'BUY',
    SELL = 'SELL',
}

export enum OrderOcoStopLimitTimeInForceEnum {
    GTC = 'GTC',
    FOK = 'FOK',
    IOC = 'IOC',
}

export enum OrderOcoNewOrderRespTypeEnum {
    ACK = 'ACK',
    RESULT = 'RESULT',
    FULL = 'FULL',
    MARKET = 'MARKET',
    LIMIT = 'LIMIT',
}

export enum OrderOcoSelfTradePreventionModeEnum {
    NONE = 'NONE',
    EXPIRE_TAKER = 'EXPIRE_TAKER',
    EXPIRE_MAKER = 'EXPIRE_MAKER',
    EXPIRE_BOTH = 'EXPIRE_BOTH',
    DECREMENT = 'DECREMENT',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum OrderTestSideEnum {
    BUY = 'BUY',
    SELL = 'SELL',
}

export enum OrderTestTypeEnum {
    MARKET = 'MARKET',
    LIMIT = 'LIMIT',
    STOP_LOSS = 'STOP_LOSS',
    STOP_LOSS_LIMIT = 'STOP_LOSS_LIMIT',
    TAKE_PROFIT = 'TAKE_PROFIT',
    TAKE_PROFIT_LIMIT = 'TAKE_PROFIT_LIMIT',
    LIMIT_MAKER = 'LIMIT_MAKER',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum OrderTestTimeInForceEnum {
    GTC = 'GTC',
    IOC = 'IOC',
    FOK = 'FOK',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum OrderTestNewOrderRespTypeEnum {
    ACK = 'ACK',
    RESULT = 'RESULT',
    FULL = 'FULL',
    MARKET = 'MARKET',
    LIMIT = 'LIMIT',
}

export enum OrderTestSelfTradePreventionModeEnum {
    NONE = 'NONE',
    EXPIRE_TAKER = 'EXPIRE_TAKER',
    EXPIRE_MAKER = 'EXPIRE_MAKER',
    EXPIRE_BOTH = 'EXPIRE_BOTH',
    DECREMENT = 'DECREMENT',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum SorOrderSideEnum {
    BUY = 'BUY',
    SELL = 'SELL',
}

export enum SorOrderTypeEnum {
    MARKET = 'MARKET',
    LIMIT = 'LIMIT',
    STOP_LOSS = 'STOP_LOSS',
    STOP_LOSS_LIMIT = 'STOP_LOSS_LIMIT',
    TAKE_PROFIT = 'TAKE_PROFIT',
    TAKE_PROFIT_LIMIT = 'TAKE_PROFIT_LIMIT',
    LIMIT_MAKER = 'LIMIT_MAKER',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum SorOrderTimeInForceEnum {
    GTC = 'GTC',
    IOC = 'IOC',
    FOK = 'FOK',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}

export enum SorOrderNewOrderRespTypeEnum {
    ACK = 'ACK',
    RESULT = 'RESULT',
    FULL = 'FULL',
    MARKET = 'MARKET',
    LIMIT = 'LIMIT',
}

export enum SorOrderSelfTradePreventionModeEnum {
    NONE = 'NONE',
    EXPIRE_TAKER = 'EXPIRE_TAKER',
    EXPIRE_MAKER = 'EXPIRE_MAKER',
    EXPIRE_BOTH = 'EXPIRE_BOTH',
    DECREMENT = 'DECREMENT',
    NON_REPRESENTABLE = 'NON_REPRESENTABLE',
}
